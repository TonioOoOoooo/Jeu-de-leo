<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="screen-orientation" content="landscape">
    <title>L'Aventure de L√©o - Version 2.0</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Patrick+Hand&display=swap');

        * { box-sizing: border-box; }
        
        body {
            margin: 0;
            padding: 0;
            background-color: #fffdf0;
            overflow: hidden;
            font-family: 'Patrick Hand', 'Comic Sans MS', cursive, sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        canvas {
            display: block;
            margin: 0 auto;
            cursor: pointer;
        }

        /* ===== UI LAYER ===== */
        #ui-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            z-index: 10;
        }

        /* ===== HUD ===== */
        #hud {
            padding: 15px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            background: linear-gradient(to bottom, rgba(0,0,0,0.3), transparent);
        }

        #level-display {
            font-size: 28px;
            color: #fff;
            text-shadow: 2px 2px 0 #333, -1px -1px 0 #333;
            font-weight: bold;
        }

        #hearts {
            font-size: 28px;
            text-shadow: 2px 2px 0 #333;
        }

        #key-display {
            font-size: 24px;
            color: gold;
            text-shadow: 2px 2px 0 #000;
            display: none;
            animation: pulse 0.5s infinite alternate;
        }

        #coins-display {
            font-size: 24px;
            color: gold;
            text-shadow: 2px 2px 0 #000;
        }

        #jump-indicator {
            position: absolute;
            bottom: 200px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
        }

        .jump-dot {
            width: 15px; height: 15px;
            border-radius: 50%;
            background: rgba(255,255,255,0.3);
            border: 2px solid white;
            transition: background 0.2s;
        }

        .jump-dot.available {
            background: #2ecc71;
            box-shadow: 0 0 10px #2ecc71;
        }

        /* ===== PROGRESS BAR ===== */
        #progress-bar {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
        }

        .progress-dot {
            width: 20px; height: 20px;
            border-radius: 50%;
            background: rgba(255,255,255,0.3);
            border: 2px solid rgba(255,255,255,0.5);
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            text-shadow: 1px 1px 0 #000;
        }

        .progress-dot.completed {
            background: #2ecc71;
            border-color: #27ae60;
        }

        .progress-dot.current {
            background: #f39c12;
            border-color: #e67e22;
            animation: pulse 0.5s infinite alternate;
        }

        /* ===== TUTORIAL ===== */
        #tutorial {
            position: absolute;
            top: 50%;
            left: 100px;
            transform: translateY(-50%);
            background: rgba(255,255,255,0.95);
            padding: 20px;
            border-radius: 15px;
            border: 3px solid #333;
            max-width: 250px;
            display: none;
            pointer-events: auto;
            z-index: 25;
        }

        #tutorial h3 {
            margin: 0 0 10px 0;
            color: #e67e22;
        }

        #tutorial p {
            margin: 5px 0;
            font-size: 16px;
        }

        #tutorial button {
            margin-top: 15px;
            padding: 10px 20px;
            background: #27ae60;
            color: white;
            border: none;
            border-radius: 10px;
            font-family: inherit;
            font-size: 18px;
            cursor: pointer;
        }

        /* ===== TIMER ===== */
        #timer-display {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 20px;
            color: white;
            text-shadow: 2px 2px 0 #333;
            display: none;
        }

        /* ===== SCREENS ===== */
        .screen {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
            pointer-events: auto;
            text-align: center;
        }

        #start-screen {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        #pause-screen {
            background: rgba(0,0,0,0.8);
            display: none;
        }

        #transition-screen {
            background: black;
            display: none;
            opacity: 0;
            transition: opacity 0.5s;
        }

        .game-title {
            font-size: 60px;
            color: white;
            text-shadow: 4px 4px 0 #333, 6px 6px 0 rgba(0,0,0,0.3);
            margin: 0;
            animation: bounce 1s infinite;
        }

        .subtitle {
            font-size: 24px;
            color: rgba(255,255,255,0.9);
            margin: 10px 0 30px 0;
        }

        /* ===== BUTTONS ===== */
        .difficulty-container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .big-btn {
            color: white;
            border: 4px solid #333;
            padding: 15px 30px;
            font-size: 24px;
            font-family: inherit;
            cursor: pointer;
            border-radius: 20px;
            box-shadow: 5px 5px 0px #333;
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .big-btn:hover {
            transform: translate(-2px, -2px);
            box-shadow: 7px 7px 0px #333;
        }

        .big-btn:active {
            transform: translate(2px, 2px);
            box-shadow: 3px 3px 0px #333;
        }

        .btn-easy { background: #27ae60; }
        .btn-medium { background: #f39c12; }
        .btn-hard { background: #c0392b; }
        .btn-continue { background: #3498db; }
        .btn-pause { background: #9b59b6; }

        /* ===== OPTIONS ===== */
        .options {
            margin-top: 30px;
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .option-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
            color: white;
            font-size: 18px;
        }

        .toggle-switch {
            width: 50px;
            height: 26px;
            background: #555;
            border-radius: 13px;
            position: relative;
            cursor: pointer;
            transition: background 0.3s;
        }

        .toggle-switch.active {
            background: #2ecc71;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 22px;
            height: 22px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: left 0.3s;
        }

        .toggle-switch.active::after {
            left: 26px;
        }

        /* ===== CONTROLS ===== */
        #controls {
            pointer-events: auto;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            padding: 20px;
            padding-bottom: 40px;
            width: 100%;
        }

        .d-pad {
            display: flex;
            gap: 15px;
        }

        .d-pad-right {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }

        .btn {
            background: rgba(255, 255, 255, 0.6);
            border: 3px solid rgba(51, 51, 51, 0.6);
            border-radius: 50%;
            width: 110px;
            height: 110px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 50px;
            color: #333;
            font-weight: bold;
            box-shadow: 0px 4px 10px rgba(0,0,0,0.2);
            -webkit-tap-highlight-color: transparent;
            transition: transform 0.1s, background 0.1s;
            touch-action: none;
        }

        .btn:active {
            background: rgba(255, 255, 255, 0.9);
            transform: scale(0.95);
        }

        #btn-jump {
            width: 130px;
            height: 130px;
            background: rgba(46, 204, 113, 0.6);
            font-size: 40px;
            border-color: rgba(39, 174, 96, 0.8);
        }

        #btn-climb {
            width: 80px;
            height: 80px;
            background: rgba(155, 89, 182, 0.6);
            font-size: 30px;
            border-color: rgba(142, 68, 173, 0.8);
        }

        #btn-pause-mobile {
            position: absolute;
            top: 15px;
            right: 80px;
            width: 50px;
            height: 50px;
            font-size: 24px;
            pointer-events: auto;
        }

        /* ===== MESSAGE BOX ===== */
        #message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 40px;
            border: 6px solid #333;
            border-radius: 25px;
            text-align: center;
            display: none;
            pointer-events: auto;
            box-shadow: 15px 15px 0px rgba(0,0,0,0.1);
            z-index: 30;
            min-width: 320px;
        }

        .space-hint {
            font-size: 16px;
            color: #888;
            margin-top: 15px;
        }

        /* ===== ANIMATIONS ===== */
        @keyframes pulse {
            from { transform: scale(1); }
            to { transform: scale(1.1); }
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        .shake {
            animation: shake 0.1s linear 3;
        }

        /* ===== RESPONSIVE ===== */
        @media (min-width: 1024px) {
            #controls { display: none; }
            #btn-pause-mobile { display: none; }
        }

        @media (max-width: 600px) {
            .game-title { font-size: 40px; }
            .big-btn { padding: 12px 20px; font-size: 20px; }
            .btn { width: 90px; height: 90px; font-size: 40px; }
            #btn-jump { width: 110px; height: 110px; }
        }

        /* ===== SAVED GAME INDICATOR ===== */
        #saved-game {
            margin-top: 20px;
            padding: 15px 25px;
            background: rgba(255,255,255,0.2);
            border-radius: 15px;
            color: white;
        }

        #saved-game p {
            margin: 5px 0;
        }
    </style>
</head>
<body>

    <!-- START SCREEN -->
    <div id="start-screen" class="screen">
        <h1 class="game-title">ü¶∏ L'Aventure de L√©o</h1>
        <p class="subtitle">Un jeu de plateforme √©pique en 9 niveaux !</p>
        
        <div id="saved-game" style="display: none;">
            <p>üìÅ Partie sauvegard√©e trouv√©e !</p>
            <p id="saved-info"></p>
            <button class="big-btn btn-continue" onclick="continueSavedGame()">‚ñ∂Ô∏è CONTINUER</button>
        </div>
        
        <p style="font-size: 22px; color: rgba(255,255,255,0.9); margin-top: 20px;">Nouvelle partie - Choisis ta difficult√© :</p>
        
        <div class="difficulty-container">
            <button class="big-btn btn-easy" onclick="startGame('easy')">üòä FACILE</button>
            <button class="big-btn btn-medium" onclick="startGame('medium')">üòê MOYEN</button>
            <button class="big-btn btn-hard" onclick="startGame('hard')">üòà DUR</button>
        </div>
        
        <div class="options">
            <div class="option-toggle">
                <span>üîä Sons</span>
                <div class="toggle-switch active" id="sound-toggle" onclick="toggleSound()"></div>
            </div>
            <div class="option-toggle">
                <span>‚è±Ô∏è Timer</span>
                <div class="toggle-switch" id="timer-toggle" onclick="toggleTimer()"></div>
            </div>
        </div>
        
        <p style="margin-top: 30px; color: rgba(255,255,255,0.7); font-size: 14px;">
            Clavier : ‚Üê ‚Üí pour bouger | ESPACE pour sauter | ‚Üë‚Üì pour les √©chelles<br>
            √âCHAP pour pause | 1-9 pour niveau (debug)
        </p>
    </div>

    <!-- PAUSE SCREEN -->
    <div id="pause-screen" class="screen">
        <h2 style="font-size: 50px; color: white; margin: 0;">‚è∏Ô∏è PAUSE</h2>
        <p style="font-size: 24px; color: rgba(255,255,255,0.8);">Niveau <span id="pause-level">1</span></p>
        
        <div class="difficulty-container" style="margin-top: 30px;">
            <button class="big-btn btn-continue" onclick="resumeGame()">‚ñ∂Ô∏è REPRENDRE</button>
            <button class="big-btn btn-easy" onclick="restartLevel()">üîÑ RECOMMENCER</button>
            <button class="big-btn btn-hard" onclick="quitToMenu()">üè† MENU</button>
        </div>
        
        <p style="margin-top: 30px; color: rgba(255,255,255,0.5);">(√âCHAP pour reprendre)</p>
    </div>

    <!-- TRANSITION SCREEN -->
    <div id="transition-screen" class="screen">
        <h2 id="transition-text" style="font-size: 50px; color: white;">NIVEAU 2</h2>
    </div>

    <!-- UI LAYER -->
    <div id="ui-layer">
        <div id="hud">
            <span id="level-display">NIVEAU 1</span>
            <span id="coins-display">ü™ô 0</span>
            <span id="hearts">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span>
            <span id="key-display">üóùÔ∏è CL√â !</span>
        </div>
        
        <div id="timer-display">‚è±Ô∏è 00:00</div>
        
        <div id="progress-bar"></div>
        
        <div id="jump-indicator">
            <div class="jump-dot available" id="jump1"></div>
            <div class="jump-dot available" id="jump2"></div>
        </div>
        
        <div id="tutorial">
            <h3>üéÆ Comment jouer</h3>
            <p>‚Üê ‚Üí pour bouger</p>
            <p>ESPACE pour sauter (x2 !)</p>
            <p>‚Üë‚Üì sur les √©chelles</p>
            <p>üóùÔ∏è Trouve la cl√© pour ouvrir la porte !</p>
            <button onclick="closeTutorial()">C'est parti ! üöÄ</button>
        </div>

        <div id="message-box">
            <h2 id="msg-title" style="font-size: 50px; margin: 0;">Bravo !</h2>
            <p id="msg-text" style="font-size: 28px;">...</p>
            <p id="msg-coins" style="font-size: 20px; color: gold;"></p>
            <button class="big-btn btn-easy" id="msg-btn" onclick="nextLevelAction()">Continuer</button>
            <p class="space-hint" id="msg-hint">(ESPACE pour continuer)</p>
        </div>

        <div class="btn" id="btn-pause-mobile" onclick="togglePause()">‚è∏Ô∏è</div>

        <div id="controls">
            <div class="d-pad">
                <div class="btn" id="btn-left">‚Üê</div>
                <div class="btn" id="btn-right">‚Üí</div>
            </div>
            <div class="d-pad-right">
                <div class="btn" id="btn-climb">‚ÜïÔ∏è</div>
                <div class="btn" id="btn-jump">SAUT</div>
            </div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
    // ============================================================
    // L'AVENTURE DE L√âO - VERSION 2.0
    // Un jeu de plateforme pour enfants avec 9 niveaux + Boss
    // ============================================================

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // ===== CONFIGURATION GLOBALE =====
    const CONFIG = {
        TIME_STEP: 1000 / 60,
        GRAVITY: 0.8,
        FRICTION: 0.85,
        MAX_FALL_SPEED: 15,
        TOTAL_LEVELS: 9
    };

    // ===== √âTAT DU JEU =====
    const GameState = {
        MENU: 'menu',
        PLAYING: 'playing',
        PAUSED: 'paused',
        TRANSITIONING: 'transitioning',
        GAME_OVER: 'game_over',
        VICTORY: 'victory'
    };

    let state = {
        current: GameState.MENU,
        level: 1,
        lives: 3,
        coins: 0,
        totalCoins: 0,
        hasKey: false,
        difficulty: 1,
        soundEnabled: true,
        timerEnabled: false,
        levelTime: 0,
        invincibilityTimer: 0,
        teleportTimer: 0,
        frameTick: 0,
        lastTime: 0,
        accumulator: 0,
        animationId: null,
        tutorialShown: false,
        screenShake: 0
    };

    // ===== SYST√àME AUDIO =====
    const AudioSystem = {
        ctx: null,
        enabled: true,
        
        init() {
            try {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            } catch(e) {
                console.log('Audio non support√©');
            }
        },
        
        resume() {
            if (this.ctx && this.ctx.state === 'suspended') {
                this.ctx.resume();
            }
        },
        
        play(type) {
            if (!this.enabled || !this.ctx) return;
            this.resume();
            
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            
            const now = this.ctx.currentTime;
            
            switch(type) {
                case 'jump':
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(300, now);
                    osc.frequency.exponentialRampToValueAtTime(600, now + 0.1);
                    gain.gain.setValueAtTime(0.2, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                    osc.start(now);
                    osc.stop(now + 0.15);
                    break;
                    
                case 'coin':
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(880, now);
                    osc.frequency.setValueAtTime(1174, now + 0.05);
                    gain.gain.setValueAtTime(0.2, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                    osc.start(now);
                    osc.stop(now + 0.15);
                    break;
                    
                case 'key':
                    osc.type = 'sine';
                    [523, 659, 784, 1046].forEach((freq, i) => {
                        osc.frequency.setValueAtTime(freq, now + i * 0.1);
                    });
                    gain.gain.setValueAtTime(0.25, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                    osc.start(now);
                    osc.stop(now + 0.5);
                    break;
                    
                case 'hurt':
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(200, now);
                    osc.frequency.exponentialRampToValueAtTime(50, now + 0.3);
                    gain.gain.setValueAtTime(0.3, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                    osc.start(now);
                    osc.stop(now + 0.3);
                    break;
                    
                case 'victory':
                    osc.type = 'sine';
                    [523, 659, 784, 1046, 784, 1046].forEach((freq, i) => {
                        osc.frequency.setValueAtTime(freq, now + i * 0.12);
                    });
                    gain.gain.setValueAtTime(0.25, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.8);
                    osc.start(now);
                    osc.stop(now + 0.8);
                    break;
                    
                case 'death':
                    osc.type = 'square';
                    [200, 180, 160, 140, 100].forEach((freq, i) => {
                        osc.frequency.setValueAtTime(freq, now + i * 0.15);
                    });
                    gain.gain.setValueAtTime(0.25, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.8);
                    osc.start(now);
                    osc.stop(now + 0.8);
                    break;
                    
                case 'boss_hit':
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(100, now);
                    osc.frequency.exponentialRampToValueAtTime(300, now + 0.1);
                    gain.gain.setValueAtTime(0.3, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                    osc.start(now);
                    osc.stop(now + 0.2);
                    break;
            }
        }
    };

    // ===== SYST√àME DE PARTICULES =====
    const ParticleSystem = {
        particles: [],
        
        emit(x, y, type, count = 10) {
            for (let i = 0; i < count; i++) {
                const p = {
                    x, y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8 - 2,
                    life: 1,
                    decay: 0.02 + Math.random() * 0.02,
                    size: 3 + Math.random() * 5,
                    type
                };
                
                if (type === 'dust') {
                    p.vy = -Math.random() * 2;
                    p.vx = (Math.random() - 0.5) * 3;
                    p.size = 2 + Math.random() * 3;
                    p.decay = 0.05;
                }
                else if (type === 'sparkle') {
                    p.vy = -Math.random() * 5;
                    p.size = 2 + Math.random() * 4;
                }
                else if (type === 'damage') {
                    p.vx = (Math.random() - 0.5) * 10;
                    p.vy = (Math.random() - 0.5) * 10;
                    p.size = 4 + Math.random() * 6;
                }
                
                this.particles.push(p);
            }
        },
        
        update() {
            for (let i = this.particles.length - 1; i >= 0; i--) {
                const p = this.particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.2;
                p.life -= p.decay;
                
                if (p.life <= 0) {
                    this.particles.splice(i, 1);
                }
            }
        },
        
        draw(ctx) {
            for (const p of this.particles) {
                ctx.globalAlpha = p.life;
                
                if (p.type === 'dust') {
                    ctx.fillStyle = '#a0522d';
                } else if (p.type === 'sparkle') {
                    ctx.fillStyle = `hsl(${50 + Math.random() * 20}, 100%, 70%)`;
                } else if (p.type === 'coin') {
                    ctx.fillStyle = 'gold';
                } else if (p.type === 'damage') {
                    ctx.fillStyle = '#e74c3c';
                } else if (p.type === 'boss') {
                    ctx.fillStyle = '#9b59b6';
                }
                
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
        },
        
        clear() {
            this.particles = [];
        }
    };

    // ===== JOUEUR =====
    const player = {
        x: 50, y: 50,
        w: 36, h: 48,
        vx: 0, vy: 0,
        baseSpeed: 6,
        jumpForce: 14,
        grounded: false,
        climbing: false,
        jumpCount: 0,
        maxJumps: 2,
        currentPlatform: null,
        facingRight: true,
        animFrame: 0,
        animTimer: 0,
        
        reset(x, y) {
            this.x = x;
            this.y = y;
            this.vx = 0;
            this.vy = 0;
            this.grounded = false;
            this.climbing = false;
            this.jumpCount = 0;
            this.currentPlatform = null;
        },
        
        draw(ctx) {
            if (state.invincibilityTimer > 0 && state.invincibilityTimer % 10 >= 5) {
                return; // Clignotement
            }
            
            ctx.save();
            const cx = this.x + this.w / 2;
            const cy = this.y + this.h / 2;
            
            if (!this.facingRight) {
                ctx.translate(cx, 0);
                ctx.scale(-1, 1);
                ctx.translate(-cx, 0);
            }
            
            // Corps (bleu)
            ctx.fillStyle = '#3498db';
            ctx.beginPath();
            ctx.ellipse(cx, cy + 5, this.w / 2 - 2, this.h / 2 - 5, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // T√™te
            ctx.fillStyle = '#f5d0a9';
            ctx.beginPath();
            ctx.arc(cx, this.y + 12, 14, 0, Math.PI * 2);
            ctx.fill();
            
            // Cheveux
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.arc(cx, this.y + 6, 12, Math.PI, 0);
            ctx.fill();
            ctx.fillRect(cx - 10, this.y + 2, 20, 8);
            
            // Yeux
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.ellipse(cx - 5, this.y + 12, 4, 5, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(cx + 5, this.y + 12, 4, 5, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.arc(cx - 4, this.y + 13, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(cx + 6, this.y + 13, 2, 0, Math.PI * 2);
            ctx.fill();
            
            // Sourire
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(cx, this.y + 16, 5, 0.2, Math.PI - 0.2);
            ctx.stroke();
            
            // Bras (animation)
            ctx.fillStyle = '#3498db';
            const armSwing = Math.sin(this.animFrame * 0.3) * (Math.abs(this.vx) > 0.5 ? 15 : 5);
            
            // Bras gauche
            ctx.save();
            ctx.translate(this.x + 5, this.y + 25);
            ctx.rotate((-20 + armSwing) * Math.PI / 180);
            ctx.fillRect(-3, 0, 6, 18);
            ctx.restore();
            
            // Bras droit
            ctx.save();
            ctx.translate(this.x + this.w - 5, this.y + 25);
            ctx.rotate((20 - armSwing) * Math.PI / 180);
            ctx.fillRect(-3, 0, 6, 18);
            ctx.restore();
            
            // Main (couleur peau)
            ctx.fillStyle = '#f5d0a9';
            ctx.beginPath();
            ctx.arc(this.x + 5 + Math.sin((-20 + armSwing) * Math.PI / 180) * 18, 
                    this.y + 25 + Math.cos((-20 + armSwing) * Math.PI / 180) * 18, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(this.x + this.w - 5 + Math.sin((20 - armSwing) * Math.PI / 180) * 18,
                    this.y + 25 + Math.cos((20 - armSwing) * Math.PI / 180) * 18, 4, 0, Math.PI * 2);
            ctx.fill();
            
            // Jambes (animation)
            ctx.fillStyle = '#2c3e50';
            const legSwing = Math.sin(this.animFrame * 0.3) * (Math.abs(this.vx) > 0.5 ? 20 : 0);
            
            if (!this.grounded && this.vy < 0) {
                // Saut : jambes pli√©es
                ctx.fillRect(cx - 10, this.y + this.h - 15, 8, 12);
                ctx.fillRect(cx + 2, this.y + this.h - 15, 8, 12);
            } else {
                // Jambe gauche
                ctx.save();
                ctx.translate(cx - 6, this.y + this.h - 18);
                ctx.rotate(legSwing * Math.PI / 180);
                ctx.fillRect(-4, 0, 8, 18);
                ctx.restore();
                
                // Jambe droite
                ctx.save();
                ctx.translate(cx + 6, this.y + this.h - 18);
                ctx.rotate(-legSwing * Math.PI / 180);
                ctx.fillRect(-4, 0, 8, 18);
                ctx.restore();
            }
            
            // Chaussures
            ctx.fillStyle = '#c0392b';
            if (!this.grounded && this.vy < 0) {
                ctx.fillRect(cx - 12, this.y + this.h - 5, 10, 5);
                ctx.fillRect(cx + 2, this.y + this.h - 5, 10, 5);
            } else {
                const leftFootX = cx - 6 + Math.sin(legSwing * Math.PI / 180) * 18;
                const rightFootX = cx + 6 + Math.sin(-legSwing * Math.PI / 180) * 18;
                ctx.fillRect(leftFootX - 6, this.y + this.h - 2, 10, 5);
                ctx.fillRect(rightFootX - 4, this.y + this.h - 2, 10, 5);
            }
            
            ctx.restore();
            
            // Animation frame
            if (Math.abs(this.vx) > 0.5 || !this.grounded) {
                this.animFrame++;
            }
        }
    };

    // ===== DONN√âES DES NIVEAUX =====
    const LEVELS = {
        1: {
            name: "La Prairie",
            bgColor: "#fffdf0",
            playerStart: { x: 50, y: 100 },
            setup: (w, h) => {
                const unit = h / 10;
                const level = { platforms: [], hazards: [], enemies: [], ladders: [], coins: [], fireBars: [], portals: [], projectiles: [] };
                
                // Sol de d√©part
                level.platforms.push({ x: -100, y: unit * 2, w: 600, h: unit });
                
                // Pi√®ces sur le d√©part
                for (let i = 0; i < 3; i++) {
                    level.coins.push({ x: 150 + i * 50, y: unit * 2 - 50, w: 20, h: 20 });
                }
                
                // Plateforme avec pi√®ges
                let trapX = 550, trapY = unit * 3;
                level.platforms.push({ x: trapX, y: trapY, w: unit * 4, h: unit });
                level.hazards.push({ x: trapX + 30, y: trapY - 25, w: 25, h: 25, type: 'spike' });
                level.hazards.push({ x: trapX + 130, y: trapY - 25, w: 25, h: 25, type: 'spike' });
                level.coins.push({ x: trapX + 80, y: trapY - 60, w: 20, h: 20 });
                
                if (state.difficulty > 1.2) {
                    level.hazards.push({ x: trapX + 80, y: trapY - 25, w: 25, h: 25, type: 'spike' });
                }
                
                // Toboggan
                let slideX = trapX + unit * 4;
                level.platforms.push({ x: slideX, y: unit * 3, w: unit * 4, h: unit * 2.5, type: 'slide_visual' });
                for (let i = 0; i < 8; i++) {
                    level.platforms.push({
                        x: slideX + (i * unit * 0.5),
                        y: unit * 3 + (i * unit * 0.3),
                        w: unit * 0.55,
                        h: unit * 0.4 + 40,
                        type: 'slide'
                    });
                }
                
                // Zone zombie
                let zombiePlatX = slideX + unit * 4;
                let zombiePlatY = unit * 5;
                level.platforms.push({ x: zombiePlatX, y: zombiePlatY, w: unit * 8, h: unit });
                level.enemies.push({
                    x: zombiePlatX + 200, y: zombiePlatY - 60,
                    w: 50, h: 60, type: 'zombie',
                    patrolStart: zombiePlatX + 50, patrolEnd: zombiePlatX + unit * 7,
                    dir: 1, speed: 2 * state.difficulty
                });
                
                for (let i = 0; i < 5; i++) {
                    level.coins.push({ x: zombiePlatX + 50 + i * 80, y: zombiePlatY - 50, w: 20, h: 20 });
                }
                
                // √âchelle
                let ladderX = zombiePlatX + unit * 7;
                let floorY = h - unit * 1.5;
                level.ladders.push({ x: ladderX, y: zombiePlatY, w: 60, h: floorY - zombiePlatY });
                
                // Sol final
                level.platforms.push({ x: ladderX - 500, y: floorY, w: w + 1000, h: unit * 2 });
                
                // Coffre monstre
                level.enemies.push({
                    x: ladderX - 200, y: floorY - 60,
                    w: 60, h: 60, type: 'chest_monster',
                    patrolStart: ladderX - 350, patrolEnd: ladderX - 100,
                    dir: 1, speed: 2 * state.difficulty
                });
                
                if (state.difficulty > 1.2) {
                    level.enemies.push({
                        x: ladderX + 100, y: floorY - 60,
                        w: 60, h: 60, type: 'chest_monster',
                        patrolStart: ladderX, patrolEnd: ladderX + 300,
                        dir: -1, speed: 2.5 * state.difficulty
                    });
                }
                
                level.keyItem = { x: ladderX - 400, y: floorY - 50, w: 40, h: 40 };
                level.goal = { x: ladderX + 300, y: floorY - 80, w: 70, h: 80 };
                level.hazards.push({ x: -1000, y: h + 100, w: w * 20, h: 100, type: 'void' });
                
                return level;
            }
        },
        
        2: {
            name: "Les Plateformes",
            bgColor: "#e8f4f8",
            playerStart: { x: 20, y: 200 },
            setup: (w, h) => {
                const unit = h / 10;
                const level = { platforms: [], hazards: [], enemies: [], ladders: [], coins: [], fireBars: [], portals: [], projectiles: [] };
                
                level.platforms.push({ x: -50, y: unit * 5, w: 200, h: unit });
                
                // Plateforme mobile horizontale
                level.platforms.push({ x: 150, y: unit * 5, w: 120, h: 20, type: 'moving', vx: 1.5 * state.difficulty, minX: 150, maxX: 400 });
                
                for (let i = 0; i < 3; i++) {
                    level.coins.push({ x: 180 + i * 30, y: unit * 5 - 40, w: 20, h: 20 });
                }
                
                let midLandX = 450, midLandY = unit * 5;
                level.platforms.push({ x: midLandX, y: midLandY, w: unit * 6, h: unit });
                level.enemies.push({
                    x: midLandX + 200, y: midLandY - 60,
                    w: 60, h: 60, type: 'chest_monster',
                    patrolStart: midLandX, patrolEnd: midLandX + unit * 5,
                    dir: 1, speed: 2 * state.difficulty
                });
                
                // Ascenseur
                let liftX = midLandX + unit * 6 + 20;
                level.platforms.push({ x: liftX, y: midLandY, w: 100, h: 20, type: 'moving', vy: -2 * state.difficulty, minY: unit * 2, maxY: midLandY, vx: 0 });
                
                // Plateforme haute
                let topX = liftX + 120;
                level.platforms.push({ x: topX, y: unit * 2, w: unit * 4, h: 20 });
                level.enemies.push({
                    x: topX + 50, y: unit * 2 - 60,
                    w: 50, h: 60, type: 'zombie',
                    patrolStart: topX, patrolEnd: topX + unit * 3,
                    dir: 1, speed: 2 * state.difficulty
                });
                
                for (let i = 0; i < 4; i++) {
                    level.coins.push({ x: topX + 50 + i * 60, y: unit * 2 - 50, w: 20, h: 20 });
                }
                
                level.keyItem = { x: topX + unit * 3, y: unit * 2 - 50, w: 40, h: 40 };
                
                let exitY = h - unit;
                level.platforms.push({ x: midLandX - 200, y: exitY, w: w + 200, h: unit });
                level.goal = { x: topX + 300, y: exitY - 80, w: 70, h: 80 };
                
                // Chemins alternatifs
                level.platforms.push({ x: midLandX - 300, y: exitY, w: 100, h: 20, type: 'moving', vy: -1.5, minY: unit * 5, maxY: exitY, vx: 0 });
                level.platforms.push({ x: midLandX - 400, y: unit * 5, w: 80, h: 20 });
                level.platforms.push({ x: topX + unit * 5, y: unit * 4, w: 100, h: 20 });
                level.platforms.push({ x: topX + unit * 6, y: unit * 6, w: 100, h: 20 });
                
                level.hazards.push({ x: -1000, y: h + 50, w: w * 30, h: 100, type: 'void' });
                
                return level;
            }
        },
        
        3: {
            name: "Le Donjon",
            bgColor: "#2c3e50",
            playerStart: { x: 50, y: 300 },
            setup: (w, h) => {
                const unit = h / 10;
                const level = { platforms: [], hazards: [], enemies: [], ladders: [], coins: [], fireBars: [], portals: [], projectiles: [] };
                
                level.platforms.push({ x: -50, y: unit * 6, w: 200, h: unit });
                
                // √éles avec barres de feu
                let isle1 = 250;
                level.platforms.push({ x: isle1, y: unit * 6, w: 100, h: unit });
                level.fireBars.push({ cx: isle1 + 50, cy: unit * 6 + 10, length: 120, angle: 0, speed: 0.05 * state.difficulty });
                level.coins.push({ x: isle1 + 40, y: unit * 6 - 120, w: 20, h: 20 });
                
                let isle2 = 450;
                level.platforms.push({ x: isle2, y: unit * 5, w: 100, h: unit });
                level.fireBars.push({ cx: isle2 + 50, cy: unit * 5 + 10, length: 130, angle: Math.PI, speed: -0.06 * state.difficulty });
                level.coins.push({ x: isle2 + 40, y: unit * 5 - 120, w: 20, h: 20 });
                
                let isle3 = 650;
                level.platforms.push({ x: isle3, y: unit * 4, w: 100, h: unit });
                level.coins.push({ x: isle3 + 40, y: unit * 4 - 50, w: 20, h: 20 });
                
                // Pont final
                let bridgeX = 850;
                level.platforms.push({ x: bridgeX, y: unit * 4, w: 400, h: unit });
                level.enemies.push({
                    x: bridgeX + 200, y: unit * 4 - 80,
                    w: 80, h: 80, type: 'chest_monster',
                    patrolStart: bridgeX, patrolEnd: bridgeX + 300,
                    dir: 1, speed: 3 * state.difficulty
                });
                
                for (let i = 0; i < 5; i++) {
                    level.coins.push({ x: bridgeX + 50 + i * 60, y: unit * 4 - 50, w: 20, h: 20 });
                }
                
                level.goal = { x: bridgeX + 350, y: unit * 4 - 60, w: 40, h: 60, type: 'axe' };
                level.hazards.push({ x: -1000, y: h - 50, w: w * 30, h: 100, type: 'lava_floor' });
                
                return level;
            }
        },
        
        4: {
            name: "Monde Champignon",
            bgColor: "#5c94fc",
            playerStart: { x: 50, y: 400 },
            setup: (w, h) => {
                const unit = h / 10;
                const level = { platforms: [], hazards: [], enemies: [], ladders: [], coins: [], fireBars: [], portals: [], projectiles: [], clouds: [] };
                
                // Nuages d√©coratifs
                for (let i = 0; i < 10; i++) {
                    level.clouds.push({ x: Math.random() * w * 4, y: Math.random() * (h / 2), w: 60 + Math.random() * 40 });
                }
                
                let groundY = h - unit;
                level.platforms.push({ x: -50, y: groundY, w: 400, h: unit, type: 'brick_floor' });
                
                for (let i = 0; i < 5; i++) {
                    level.coins.push({ x: 80 + i * 60, y: groundY - 50, w: 20, h: 20 });
                }
                
                // Tuyaux
                let pipe1X = 450;
                level.platforms.push({ x: pipe1X, y: groundY - 60, w: 60, h: 60 + unit, type: 'pipe' });
                level.platforms.push({ x: pipe1X + 150, y: groundY, w: 300, h: unit, type: 'brick_floor' });
                
                level.enemies.push({
                    x: pipe1X + 200, y: groundY - 60,
                    w: 50, h: 60, type: 'zombie',
                    patrolStart: pipe1X + 150, patrolEnd: pipe1X + 400,
                    dir: -1, speed: 2 * state.difficulty
                });
                
                let pipe2X = pipe1X + 350;
                level.platforms.push({ x: pipe2X, y: groundY - 90, w: 60, h: 90 + unit, type: 'pipe' });
                
                // Blocs
                let bricksX = pipe2X + 200;
                let bricksY = groundY - 150;
                level.platforms.push({ x: bricksX, y: bricksY, w: 180, h: 40, type: 'brick_block' });
                level.platforms.push({ x: bricksX + 250, y: bricksY - 50, w: 40, h: 40, type: 'gold_block' });
                level.keyItem = { x: bricksX + 255, y: bricksY - 100, w: 30, h: 30 };
                
                for (let i = 0; i < 4; i++) {
                    level.coins.push({ x: bricksX + 20 + i * 45, y: bricksY - 50, w: 20, h: 20 });
                }
                
                // Zone finale
                let endGroundX = bricksX + 400;
                level.platforms.push({ x: endGroundX, y: groundY, w: 600, h: unit, type: 'brick_floor' });
                
                // Escaliers
                let stairsX = endGroundX + 100;
                for (let i = 0; i < 5; i++) {
                    level.platforms.push({ x: stairsX + (i * 40), y: groundY - (i * 40) - 40, w: 40, h: 40, type: 'brick_block' });
                }
                
                level.goal = { x: stairsX + 350, y: groundY - 120, w: 10, h: 120, type: 'flag' };
                level.platforms.push({ x: stairsX + 400, y: groundY - 100, w: 100, h: 100, type: 'castle' });
                
                level.hazards.push({ x: -1000, y: h + 100, w: w * 20, h: 100, type: 'void' });
                
                return level;
            }
        },
        
        5: {
            name: "Monde Cubique",
            bgColor: "#87CEEB",
            playerStart: { x: 50, y: 300 },
            setup: (w, h) => {
                const blockSize = 40;
                const level = { platforms: [], hazards: [], enemies: [], ladders: [], coins: [], fireBars: [], portals: [], projectiles: [], clouds: [] };
                
                for (let i = 0; i < 8; i++) {
                    level.clouds.push({ x: Math.random() * w * 3, y: 50 + Math.random() * 150, w: 50 + Math.random() * 40 });
                }
                
                // Sol Minecraft
                for (let i = 0; i < 15; i++) {
                    level.platforms.push({ x: i * blockSize, y: h - blockSize * 2, w: blockSize, h: blockSize, type: 'grass_block' });
                    level.platforms.push({ x: i * blockSize, y: h - blockSize, w: blockSize, h: blockSize, type: 'dirt_block' });
                }
                
                // Pi√®ces sur le sol
                for (let i = 0; i < 4; i++) {
                    level.coins.push({ x: 100 + i * 80, y: h - blockSize * 2 - 50, w: 20, h: 20 });
                }
                
                // Arbre
                let treeX = 300;
                level.platforms.push({ x: treeX, y: h - blockSize * 5, w: blockSize, h: blockSize * 3, type: 'wood' });
                level.platforms.push({ x: treeX - blockSize, y: h - blockSize * 7, w: blockSize * 3, h: blockSize * 2, type: 'leaves' });
                level.platforms.push({ x: treeX, y: h - blockSize * 8, w: blockSize, h: blockSize, type: 'leaves' });
                
                level.keyItem = { x: treeX, y: h - blockSize * 9, w: 30, h: 30, type: 'diamond' };
                
                // Zone de lave
                let caveX = 650;
                level.platforms.push({ x: caveX, y: h - blockSize * 4, w: blockSize * 2, h: blockSize, type: 'stone' });
                level.platforms.push({ x: caveX + 150, y: h - blockSize * 2, w: blockSize * 2, h: blockSize, type: 'stone' });
                level.hazards.push({ x: caveX, y: h - 20, w: 400, h: 20, type: 'lava_floor' });
                
                level.coins.push({ x: caveX + 30, y: h - blockSize * 4 - 50, w: 20, h: 20 });
                level.coins.push({ x: caveX + 180, y: h - blockSize * 2 - 50, w: 20, h: 20 });
                
                // Portail du Nether (fin)
                let netherX = caveX + 400;
                level.platforms.push({ x: netherX, y: h - blockSize * 5, w: blockSize * 4, h: blockSize, type: 'netherrack' });
                level.goal = { x: netherX + blockSize, y: h - blockSize * 5 - 80, w: 60, h: 80, type: 'nether_portal' };
                
                level.enemies.push({
                    x: netherX + 50, y: h - blockSize * 5 - 60,
                    w: 50, h: 60, type: 'zombie',
                    patrolStart: netherX, patrolEnd: netherX + 150,
                    dir: 1, speed: 2 * state.difficulty
                });
                
                level.hazards.push({ x: -1000, y: h + 100, w: w * 30, h: 100, type: 'void' });
                
                return level;
            }
        },
        
        6: {
            name: "Les Portails",
            bgColor: "#1a1a2e",
            playerStart: { x: 50, y: 400 },
            setup: (w, h) => {
                const unit = h / 10;
                const level = { platforms: [], hazards: [], enemies: [], ladders: [], coins: [], fireBars: [], portals: [], projectiles: [] };
                
                // Plateforme de d√©part
                level.platforms.push({ x: -50, y: h - unit * 2, w: 300, h: unit, type: 'metal' });
                
                // Portail 1 : t√©l√©porte en haut √† droite
                level.portals.push({
                    x: 200, y: h - unit * 2 - 80, w: 50, h: 80,
                    color: '#00FFFF',
                    destX: w - 200, destY: unit * 3 - player.h - 10
                });
                
                level.platforms.push({ x: w - 300, y: unit * 3, w: 300, h: 20, type: 'metal' });
                level.enemies.push({
                    x: w - 200, y: unit * 3 - 60,
                    w: 50, h: 60, type: 'zombie',
                    patrolStart: w - 280, patrolEnd: w - 50,
                    dir: -1, speed: 2.5 * state.difficulty
                });
                
                for (let i = 0; i < 3; i++) {
                    level.coins.push({ x: w - 280 + i * 80, y: unit * 3 - 50, w: 20, h: 20 });
                }
                
                // Portail 2 : t√©l√©porte √† gauche milieu
                level.portals.push({
                    x: w - 100, y: unit * 3 - 80, w: 50, h: 80,
                    color: '#FF9900',
                    destX: 100, destY: unit * 5 - player.h - 10
                });
                
                level.platforms.push({ x: 50, y: unit * 5, w: 300, h: 20, type: 'metal' });
                level.hazards.push({ x: 180, y: unit * 5 - 25, w: 25, h: 25, type: 'spike' });
                level.keyItem = { x: 80, y: unit * 5 - 50, w: 40, h: 40 };
                
                level.coins.push({ x: 250, y: unit * 5 - 50, w: 20, h: 20 });
                
                // Portail 3 : t√©l√©porte en bas √† droite (sortie)
                level.portals.push({
                    x: 300, y: unit * 5 - 80, w: 50, h: 80,
                    color: '#CC00FF',
                    destX: w - 150, destY: h - unit * 2 - player.h - 10
                });
                
                level.platforms.push({ x: w - 300, y: h - unit * 2, w: 300, h: unit, type: 'metal' });
                level.enemies.push({
                    x: w - 250, y: h - unit * 2 - 60,
                    w: 60, h: 60, type: 'chest_monster',
                    patrolStart: w - 280, patrolEnd: w - 100,
                    dir: 1, speed: 2
                });
                
                level.goal = { x: w - 80, y: h - unit * 2 - 80, w: 70, h: 80 };
                
                // Plateforme mobile au centre
                level.platforms.push({ x: w / 2 - 100, y: h - unit, w: 200, h: 20, type: 'moving', vx: 2, minX: 200, maxX: w - 200 });
                
                level.hazards.push({ x: -1000, y: h + 100, w: w * 20, h: 100, type: 'void' });
                
                return level;
            }
        },
        
        7: {
            name: "Les Remparts",
            bgColor: "#2d1b4e",
            playerStart: { x: 50, y: 200 },
            setup: (w, h) => {
                const level = { platforms: [], hazards: [], enemies: [], ladders: [], coins: [], fireBars: [], portals: [], projectiles: [] };
                let wallY = h / 2 + 50;
                
                // Mur de d√©part
                level.platforms.push({ x: -50, y: wallY, w: 200, h: h, type: 'castle_wall' });
                
                // Cr√©neaux avec trous
                let currentX = 150;
                for (let i = 0; i < 12; i++) {
                    let gap = (i % 3 === 1) ? 120 : 0;
                    let width = 150 + Math.random() * 80;
                    
                    if (gap > 0) {
                        level.hazards.push({
                            x: currentX + gap / 2 - 20, y: wallY + 50,
                            w: 40, h: 80, type: 'knight',
                            minY: wallY - 80, maxY: wallY + 100,
                            speed: 2 * state.difficulty, dir: 1
                        });
                    }
                    
                    level.platforms.push({ x: currentX + gap, y: wallY, w: width, h: h, type: 'castle_wall' });
                    
                    if (i % 2 === 0) {
                        level.coins.push({ x: currentX + gap + width / 2, y: wallY - 50, w: 20, h: 20 });
                    }
                    
                    currentX += gap + width;
                }
                
                // La corde (plateforme mobile rapide)
                let ropeGap = 400;
                level.platforms.push({
                    x: currentX + 50, y: wallY - 50, w: 60, h: 10,
                    type: 'moving', vx: 4 * state.difficulty,
                    minX: currentX + 50, maxX: currentX + ropeGap - 50
                });
                
                level.platforms.push({ x: currentX + ropeGap, y: wallY, w: 300, h: h, type: 'castle_wall' });
                
                // Cloche (fin)
                level.goal = { x: currentX + ropeGap + 150, y: wallY - 100, w: 60, h: 80, type: 'bell' };
                
                level.hazards.push({ x: -1000, y: h + 100, w: w * 20, h: 100, type: 'void' });
                
                return level;
            }
        },
        
        8: {
            name: "Royaume des R√™ves",
            bgColor: "#9290FF",
            playerStart: { x: 50, y: 400 },
            setup: (w, h) => {
                const unit = h / 10;
                const level = { platforms: [], hazards: [], enemies: [], ladders: [], coins: [], fireBars: [], portals: [], projectiles: [] };
                
                let groundY = h - unit;
                
                // Sol SMB2
                level.platforms.push({ x: -50, y: groundY, w: 300, h: unit, type: 'smb2_grass' });
                
                for (let i = 0; i < 3; i++) {
                    level.coins.push({ x: 80 + i * 60, y: groundY - 50, w: 20, h: 20 });
                }
                
                // Vase
                level.platforms.push({ x: 300, y: groundY - 60, w: 50, h: 60 + unit, type: 'jar' });
                
                // B√ªches flottantes
                level.platforms.push({ x: 400, y: groundY - 120, w: 100, h: 20, type: 'smb2_log' });
                level.platforms.push({ x: 550, y: groundY - 180, w: 100, h: 20, type: 'smb2_log' });
                
                // Maskass
                level.enemies.push({
                    x: 600, y: groundY - 180 - 60,
                    w: 40, h: 40, type: 'shy_guy',
                    patrolStart: 550, patrolEnd: 650,
                    dir: 1, speed: 2 * state.difficulty
                });
                
                level.coins.push({ x: 420, y: groundY - 170, w: 20, h: 20 });
                level.coins.push({ x: 570, y: groundY - 230, w: 20, h: 20 });
                
                // Sol plus loin
                level.platforms.push({ x: 700, y: groundY, w: 500, h: unit, type: 'smb2_grass' });
                
                // Navet (cl√©) en haut
                level.platforms.push({ x: 800, y: groundY - 250, w: 80, h: 20, type: 'smb2_log' });
                level.keyItem = { x: 820, y: groundY - 300, w: 30, h: 30, type: 'turnip' };
                
                for (let i = 0; i < 4; i++) {
                    level.coins.push({ x: 720 + i * 80, y: groundY - 50, w: 20, h: 20 });
                }
                
                // T√™te de Faucon (porte)
                level.goal = { x: 1000, y: groundY - 100, w: 80, h: 100, type: 'hawkmouth' };
                
                level.hazards.push({ x: -1000, y: h + 100, w: w * 20, h: 100, type: 'void' });
                
                return level;
            }
        },
        
        9: {
            name: "BOSS FINAL",
            bgColor: "#1a0a0a",
            playerStart: { x: 100, y: 400 },
            isBoss: true,
            setup: (w, h) => {
                const level = { platforms: [], hazards: [], enemies: [], ladders: [], coins: [], fireBars: [], portals: [], projectiles: [] };
                
                // Ar√®ne du boss
                let floorY = h - 80;
                level.platforms.push({ x: -50, y: floorY, w: w + 100, h: 100, type: 'boss_floor' });
                
                // Plateformes d'esquive
                level.platforms.push({ x: 150, y: floorY - 150, w: 120, h: 20 });
                level.platforms.push({ x: w - 270, y: floorY - 150, w: 120, h: 20 });
                level.platforms.push({ x: w / 2 - 60, y: floorY - 280, w: 120, h: 20 });
                
                // Boss
                level.boss = {
                    x: w - 200, y: floorY - 180,
                    w: 150, h: 180,
                    hp: 5,
                    maxHp: 5,
                    phase: 1,
                    attackTimer: 0,
                    invincible: 0,
                    dir: -1,
                    state: 'idle'
                };
                
                level.hazards.push({ x: -1000, y: h + 100, w: w * 20, h: 100, type: 'void' });
                
                return level;
            }
        }
    };

    // ===== OBJETS DU NIVEAU COURANT =====
    let currentLevelData = null;

    // ===== CONTR√îLES =====
    const keys = { right: false, left: false, up: false, down: false, jump: false };

    // ===== INITIALISATION =====
    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }

    function init() {
        resize();
        AudioSystem.init();
        checkSavedGame();
        createProgressBar();
        window.addEventListener('resize', resize);
        setupControls();
    }

    function checkSavedGame() {
        try {
            const saved = localStorage.getItem('leo_save');
            if (saved) {
                const data = JSON.parse(saved);
                if (data.level > 1) {
                    document.getElementById('saved-game').style.display = 'block';
                    document.getElementById('saved-info').textContent = 
                        `Niveau ${data.level} - ${data.totalCoins} pi√®ces - ${data.difficulty === 1 ? 'Facile' : data.difficulty > 1.3 ? 'Dur' : 'Moyen'}`;
                }
            }
        } catch(e) {}
    }

    function saveGame() {
        try {
            localStorage.setItem('leo_save', JSON.stringify({
                level: state.level,
                totalCoins: state.totalCoins,
                difficulty: state.difficulty
            }));
        } catch(e) {}
    }

    function createProgressBar() {
        const bar = document.getElementById('progress-bar');
        bar.innerHTML = '';
        for (let i = 1; i <= CONFIG.TOTAL_LEVELS; i++) {
            const dot = document.createElement('div');
            dot.className = 'progress-dot';
            dot.textContent = i;
            dot.id = `progress-${i}`;
            bar.appendChild(dot);
        }
    }

    function updateProgressBar() {
        for (let i = 1; i <= CONFIG.TOTAL_LEVELS; i++) {
            const dot = document.getElementById(`progress-${i}`);
            dot.classList.remove('completed', 'current');
            if (i < state.level) dot.classList.add('completed');
            else if (i === state.level) dot.classList.add('current');
        }
    }

    // ===== GESTION DES CONTR√îLES =====
    function setupControls() {
        // Clavier
        window.addEventListener('keydown', e => handleKey(e, true));
        window.addEventListener('keyup', e => handleKey(e, false));
        
        // Touch mobile
        const bindTouch = (id, keyName, isJump = false) => {
            const el = document.getElementById(id);
            if (!el) return;
            
            const start = (e) => {
                e.preventDefault();
                keys[keyName] = true;
                if (isJump) doJump();
            };
            const end = (e) => {
                e.preventDefault();
                keys[keyName] = false;
            };
            
            el.addEventListener('touchstart', start, { passive: false });
            el.addEventListener('touchend', end, { passive: false });
            el.addEventListener('touchcancel', end, { passive: false });
            el.addEventListener('mousedown', start);
            el.addEventListener('mouseup', end);
            el.addEventListener('mouseleave', end);
        };
        
        bindTouch('btn-left', 'left');
        bindTouch('btn-right', 'right');
        bindTouch('btn-climb', 'up');
        bindTouch('btn-jump', 'jump', true);
    }

    function handleKey(e, pressed) {
        const k = e.key.toLowerCase();
        
        if (['arrowleft', 'q', 'a'].includes(k)) keys.left = pressed;
        if (['arrowright', 'd'].includes(k)) keys.right = pressed;
        if (['arrowup', 'w', 'z'].includes(k)) keys.up = pressed;
        if (['arrowdown', 's'].includes(k)) keys.down = pressed;
        
        // Saut
        if (pressed && (k === ' ' || e.code === 'Space')) {
            e.preventDefault();
            
            // Si message affich√©, continuer
            const msgBox = document.getElementById('message-box');
            if (msgBox.style.display === 'block') {
                nextLevelAction();
                return;
            }
            
            if (state.current === GameState.PLAYING) {
                doJump();
            }
        }
        
        // Pause
        if (pressed && k === 'escape') {
            togglePause();
        }
        
        // Debug : niveaux 1-9
        if (pressed && ['1','2','3','4','5','6','7','8','9'].includes(e.key)) {
            state.level = parseInt(e.key);
            startGame('easy');
        }
    }

    function doJump() {
        AudioSystem.resume();
        
        if (player.grounded || player.climbing) {
            player.vy = -player.jumpForce;
            player.grounded = false;
            player.climbing = false;
            player.jumpCount = 1;
            AudioSystem.play('jump');
            ParticleSystem.emit(player.x + player.w / 2, player.y + player.h, 'dust', 5);
        } else if (player.jumpCount < player.maxJumps) {
            player.vy = -player.jumpForce * 0.9;
            player.jumpCount++;
            AudioSystem.play('jump');
        }
        
        updateJumpIndicator();
    }

    function updateJumpIndicator() {
        const jumpsLeft = player.maxJumps - player.jumpCount;
        document.getElementById('jump1').classList.toggle('available', jumpsLeft >= 1 || player.grounded);
        document.getElementById('jump2').classList.toggle('available', jumpsLeft >= 2 || player.grounded);
    }

    // ===== D√âMARRAGE DU JEU =====
    function startGame(difficulty) {
        AudioSystem.resume();
        
        state.difficulty = difficulty === 'easy' ? 1 : difficulty === 'medium' ? 1.3 : 1.6;
        state.lives = 3;
        state.coins = 0;
        state.totalCoins = 0;
        
        document.getElementById('start-screen').style.display = 'none';
        
        initLevel(state.level);
        state.current = GameState.PLAYING;
        
        updateHud();
        updateProgressBar();
        
        // Tutoriel au niveau 1
        if (state.level === 1 && !state.tutorialShown) {
            document.getElementById('tutorial').style.display = 'block';
            state.tutorialShown = true;
        }
        
        state.lastTime = 0;
        state.accumulator = 0;
        
        if (state.animationId) cancelAnimationFrame(state.animationId);
        requestAnimationFrame(gameLoop);
    }

    function continueSavedGame() {
        try {
            const saved = JSON.parse(localStorage.getItem('leo_save'));
            state.level = saved.level;
            state.totalCoins = saved.totalCoins;
            state.difficulty = saved.difficulty;
            const diff = state.difficulty === 1 ? 'easy' : state.difficulty > 1.3 ? 'hard' : 'medium';
            startGame(diff);
        } catch(e) {
            startGame('easy');
        }
    }

    function closeTutorial() {
        document.getElementById('tutorial').style.display = 'none';
    }

    // ===== INITIALISATION DU NIVEAU =====
    function initLevel(levelNum) {
        const levelDef = LEVELS[levelNum];
        if (!levelDef) return;
        
        currentLevelData = levelDef.setup(canvas.width, canvas.height);
        
        // Reset joueur
        player.reset(levelDef.playerStart.x, levelDef.playerStart.y);
        
        // Reset √©tat niveau
        state.hasKey = false;
        state.levelTime = 0;
        state.invincibilityTimer = 0;
        state.teleportTimer = 0;
        state.coins = 0;
        
        ParticleSystem.clear();
        
        // UI
        document.getElementById('key-display').style.display = 'none';
        document.getElementById('level-display').textContent = `NIVEAU ${levelNum}`;
        document.body.style.backgroundColor = levelDef.bgColor;
        
        updateCoinsDisplay();
    }

    // ===== BOUCLE DE JEU =====
    function gameLoop(timestamp) {
        if (state.current === GameState.MENU) return;
        
        if (!state.lastTime) state.lastTime = timestamp;
        let deltaTime = timestamp - state.lastTime;
        state.lastTime = timestamp;
        
        if (deltaTime > 100) deltaTime = 100;
        state.accumulator += deltaTime;
        
        while (state.accumulator >= CONFIG.TIME_STEP) {
            if (state.current === GameState.PLAYING) {
                update();
            }
            state.accumulator -= CONFIG.TIME_STEP;
        }
        
        draw();
        
        state.animationId = requestAnimationFrame(gameLoop);
    }

    // ===== UPDATE =====
    function update() {
        if (!currentLevelData) return;
        
        state.frameTick++;
        if (state.invincibilityTimer > 0) state.invincibilityTimer--;
        if (state.teleportTimer > 0) state.teleportTimer--;
        if (state.screenShake > 0) state.screenShake--;
        
        if (state.timerEnabled) {
            state.levelTime += CONFIG.TIME_STEP;
            updateTimerDisplay();
        }
        
        // Boss level special update
        if (LEVELS[state.level].isBoss && currentLevelData.boss) {
            updateBoss();
        }
        
        // Projectiles du niveau 7
        if (state.level === 7 && state.frameTick % 90 === 0) {
            currentLevelData.projectiles.push({
                x: canvas.width + 100,
                y: player.y + 10,
                w: 40, h: 10,
                speed: -6 * state.difficulty,
                type: 'arrow'
            });
        }
        
        updateProjectiles();
        updateEnemies();
        updatePlatforms();
        updateHazards();
        updatePortals();
        updateFireBars();
        updatePlayer();
        checkCollisions();
        
        ParticleSystem.update();
        updateJumpIndicator();
    }

    function updatePlayer() {
        const prevY = player.y;
        
        // √âchelles
        let touchingLadder = false;
        for (const l of currentLevelData.ladders) {
            if (player.x + player.w > l.x && player.x < l.x + l.w &&
                player.y + player.h > l.y - 10 && player.y < l.y + l.h + 20) {
                touchingLadder = true;
                break;
            }
        }
        
        if (touchingLadder && (keys.up || keys.down)) {
            player.climbing = true;
            player.jumpCount = 0;
            player.currentPlatform = null;
        }
        if (!touchingLadder) player.climbing = false;
        
        if (player.climbing) {
            player.vy = 0;
            player.vx = 0;
            if (keys.up) player.y -= 4;
            if (keys.down) player.y += 4;
            if (keys.left) player.x -= 2;
            if (keys.right) player.x += 2;
        } else {
            // Mouvement horizontal
            if (keys.right) {
                player.vx += 1.2;
                player.facingRight = true;
            }
            if (keys.left) {
                player.vx -= 1.2;
                player.facingRight = false;
            }
            
            player.vx *= CONFIG.FRICTION;
            
            const maxSpeed = player.baseSpeed * Math.min(state.difficulty, 1.2);
            player.vx = Math.max(-maxSpeed, Math.min(maxSpeed, player.vx));
            
            player.x += player.vx;
            
            // Gravit√©
            player.vy += CONFIG.GRAVITY;
            player.vy = Math.min(player.vy, CONFIG.MAX_FALL_SPEED);
            player.y += player.vy;
        }
        
        // Collisions plateformes
        player.grounded = false;
        let onPlatform = false;
        
        for (const p of currentLevelData.platforms) {
            if (p.type === 'slide_visual' || p.type === 'castle' || p.type === 'sonic_goal') continue;
            
            if (player.x + player.w > p.x + 5 && player.x < p.x + p.w - 5) {
                const feetNow = player.y + player.h;
                const feetBefore = prevY + player.h;
                const tolerance = (p.type === 'moving' && p.vy < 0) ? 15 - p.vy : 15;
                
                if (player.vy >= 0 && feetBefore <= p.y + tolerance && feetNow >= p.y) {
                    // Ressort
                    if (p.type === 'spring') {
                        player.vy = -22;
                        AudioSystem.play('jump');
                        continue;
                    }
                    
                    // Speed pad
                    if (p.type === 'speed_pad') {
                        player.vx = player.vx > 0 ? 15 : -15;
                    }
                    
                    player.y = p.y - player.h;
                    player.vy = 0;
                    player.grounded = true;
                    player.jumpCount = 0;
                    player.currentPlatform = p;
                    onPlatform = true;
                    
                    if (p.type === 'slide') {
                        player.vx += 4;
                    }
                }
            }
        }
        
        if (!onPlatform) player.currentPlatform = null;
        
        // Limites √©cran
        if (player.x < 0) {
            player.x = 0;
            player.vx = 0;
        }
    }

    function updateEnemies() {
        for (const e of currentLevelData.enemies) {
            if (e.patrolEnd) {
                e.x += e.dir * (e.speed || 2);
                if (e.x > e.patrolEnd) { e.x = e.patrolEnd; e.dir = -1; }
                if (e.x < e.patrolStart) { e.x = e.patrolStart; e.dir = 1; }
            }
        }
    }

    function updatePlatforms() {
        for (const p of currentLevelData.platforms) {
            if (p.type === 'moving') {
                if (p.vx) {
                    p.x += p.vx;
                    if (p.x > p.maxX || p.x < p.minX) p.vx *= -1;
                }
                if (p.vy) {
                    p.y += p.vy;
                    if (p.y > p.maxY || p.y < p.minY) p.vy *= -1;
                }
                
                // D√©placer le joueur avec la plateforme
                if (player.grounded && player.currentPlatform === p) {
                    player.x += p.vx || 0;
                    player.y += p.vy || 0;
                }
            }
        }
    }

    function updateHazards() {
        for (const h of currentLevelData.hazards) {
            if (h.type === 'knight') {
                if (!h.dir) h.dir = 1;
                h.y += h.dir * h.speed;
                if (h.y > h.maxY) h.dir = -1;
                if (h.y < h.minY) h.dir = 1;
            }
        }
    }

    function updatePortals() {
        if (state.teleportTimer > 0) return;
        
        for (const p of currentLevelData.portals) {
            if (checkCollision(player, p)) {
                player.x = p.destX;
                player.y = p.destY;
                player.vx = 0;
                player.vy = 0;
                state.teleportTimer = 60;
                ParticleSystem.emit(player.x + player.w/2, player.y + player.h/2, 'sparkle', 20);
                break;
            }
        }
    }

    function updateFireBars() {
        for (const fb of currentLevelData.fireBars) {
            fb.angle += fb.speed;
        }
    }

    function updateProjectiles() {
        for (let i = currentLevelData.projectiles.length - 1; i >= 0; i--) {
            const p = currentLevelData.projectiles[i];
            p.x += p.speed;
            if (p.x < -100 || p.x > canvas.width + 100) {
                currentLevelData.projectiles.splice(i, 1);
            }
        }
    }

    function updateBoss() {
        const boss = currentLevelData.boss;
        if (!boss || boss.hp <= 0) return;
        
        boss.attackTimer++;
        if (boss.invincible > 0) boss.invincible--;
        
        // Patterns d'attaque
        if (boss.attackTimer % 120 === 0) {
            // Tir de projectile
            const projSpeed = boss.phase === 1 ? -6 : -8;
            currentLevelData.projectiles.push({
                x: boss.x,
                y: boss.y + boss.h / 2,
                w: 30, h: 30,
                speed: projSpeed * state.difficulty,
                type: 'boss_fire'
            });
            
            if (boss.phase >= 2 && boss.attackTimer % 240 === 0) {
                // Attaque suppl√©mentaire
                currentLevelData.projectiles.push({
                    x: boss.x,
                    y: boss.y + 30,
                    w: 20, h: 20,
                    speed: -7 * state.difficulty,
                    type: 'boss_fire'
                });
                currentLevelData.projectiles.push({
                    x: boss.x,
                    y: boss.y + boss.h - 30,
                    w: 20, h: 20,
                    speed: -7 * state.difficulty,
                    type: 'boss_fire'
                });
            }
        }
        
        // Mouvement du boss
        if (boss.phase >= 2) {
            boss.x += Math.sin(state.frameTick * 0.02) * 2;
        }
    }

    // ===== COLLISIONS =====
    function checkCollision(a, b) {
        return a.x < b.x + b.w && a.x + a.w > b.x &&
               a.y < b.y + b.h && a.y + a.h > b.y;
    }

    function checkCollisions() {
        // Pi√®ces
        for (let i = currentLevelData.coins.length - 1; i >= 0; i--) {
            const c = currentLevelData.coins[i];
            if (checkCollision(player, c)) {
                currentLevelData.coins.splice(i, 1);
                state.coins++;
                state.totalCoins++;
                updateCoinsDisplay();
                AudioSystem.play('coin');
                ParticleSystem.emit(c.x + c.w/2, c.y + c.h/2, 'coin', 8);
            }
        }
        
        // Cl√©
        if (!state.hasKey && currentLevelData.keyItem) {
            if (checkCollision(player, currentLevelData.keyItem)) {
                state.hasKey = true;
                currentLevelData.keyItem = null;
                document.getElementById('key-display').style.display = 'inline';
                AudioSystem.play('key');
                ParticleSystem.emit(player.x + player.w/2, player.y, 'sparkle', 20);
            }
        }
        
        // But
        if (currentLevelData.goal && checkCollision(player, currentLevelData.goal)) {
            // Niveau 8 : besoin de la cl√©
            if (state.level === 8 && !state.hasKey) {
                if (player.x < currentLevelData.goal.x) player.x -= 5;
                return;
            }
            
            // Niveau boss : pas de goal direct
            if (LEVELS[state.level].isBoss) return;
            
            // Niveau 3 : pas besoin de cl√©
            if (state.level === 3 || state.hasKey) {
                levelWin();
                return;
            } else {
                if (player.x < currentLevelData.goal.x) player.x -= 5;
            }
        }
        
        // Boss
        if (currentLevelData.boss && currentLevelData.boss.hp > 0) {
            const boss = currentLevelData.boss;
            
            // Joueur saute sur le boss
            if (player.vy > 0 && boss.invincible === 0 &&
                player.x + player.w > boss.x && player.x < boss.x + boss.w &&
                player.y + player.h > boss.y && player.y + player.h < boss.y + 40) {
                
                boss.hp--;
                boss.invincible = 60;
                player.vy = -12;
                state.screenShake = 10;
                AudioSystem.play('boss_hit');
                ParticleSystem.emit(boss.x + boss.w/2, boss.y, 'boss', 15);
                
                if (boss.hp <= boss.maxHp / 2) boss.phase = 2;
                
                if (boss.hp <= 0) {
                    levelWin();
                    return;
                }
            }
            // Boss touche le joueur
            else if (checkCollision(player, boss) && state.invincibilityTimer === 0) {
                takeDamage("Le boss t'a touch√© !");
            }
        }
        
        // Dangers
        if (state.invincibilityTimer === 0) {
            // Barres de feu
            for (const fb of currentLevelData.fireBars) {
                const endX = fb.cx + Math.cos(fb.angle) * fb.length;
                const endY = fb.cy + Math.sin(fb.angle) * fb.length;
                
                for (let i = 0; i <= 5; i++) {
                    const px = fb.cx + (endX - fb.cx) * (i / 5);
                    const py = fb.cy + (endY - fb.cy) * (i / 5);
                    
                    if (px > player.x && px < player.x + player.w &&
                        py > player.y && py < player.y + player.h) {
                        takeDamage("Br√ªl√© !");
                        break;
                    }
                }
            }
            
            // Projectiles
            for (let i = currentLevelData.projectiles.length - 1; i >= 0; i--) {
                if (checkCollision(player, currentLevelData.projectiles[i])) {
                    takeDamage("Touch√© !");
                    currentLevelData.projectiles.splice(i, 1);
                }
            }
            
            // Obstacles
            for (const h of currentLevelData.hazards) {
                if (checkCollision(player, h)) {
                    if (h.type === 'void' || h.type === 'lava_floor') {
                        state.lives--;
                        updateHud();
                        if (state.lives <= 0) {
                            gameOver("Tomb√© !");
                        } else {
                            respawnPlayer();
                        }
                    } else {
                        takeDamage("A√Øe !");
                    }
                }
            }
            
            // Ennemis
            for (const e of currentLevelData.enemies) {
                if (checkCollision(player, e)) {
                    takeDamage("Monstre !");
                }
            }
        }
    }

    function takeDamage(reason) {
        if (state.invincibilityTimer > 0) return;
        
        state.lives--;
        state.invincibilityTimer = 90;
        state.screenShake = 15;
        
        player.vy = -10;
        player.vx = player.facingRight ? -8 : 8;
        
        updateHud();
        AudioSystem.play('hurt');
        ParticleSystem.emit(player.x + player.w/2, player.y + player.h/2, 'damage', 12);
        
        // Vibration mobile
        if (navigator.vibrate) {
            navigator.vibrate(100);
        }
        
        if (state.lives <= 0) {
            gameOver(reason || "Plus de vies !");
        }
    }

    function respawnPlayer() {
        const start = LEVELS[state.level].playerStart;
        player.reset(start.x, start.y);
        state.invincibilityTimer = 90;
    }

    // ===== DRAW =====
    function draw() {
        ctx.save();
        
        // Screen shake
        if (state.screenShake > 0) {
            ctx.translate(
                (Math.random() - 0.5) * state.screenShake,
                (Math.random() - 0.5) * state.screenShake
            );
        }
        
        // Fond
        const levelDef = LEVELS[state.level];
        ctx.fillStyle = levelDef ? levelDef.bgColor : '#fffdf0';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        if (!currentLevelData) {
            ctx.restore();
            return;
        }
        
        // Grille cahier pour niveaux 1-2
        if (state.level <= 2) {
            drawNotebookGrid();
        }
        
        // Cam√©ra
        const camX = Math.min(0, (canvas.width * 0.3) - player.x);
        ctx.save();
        ctx.translate(camX, 0);
        
        // Nuages
        if (currentLevelData.clouds) {
            drawClouds();
        }
        
        // Portails
        drawPortals();
        
        // Barres de feu
        drawFireBars();
        
        // √âchelles
        drawLadders();
        
        // Plateformes
        drawPlatforms();
        
        // Pi√®ces
        drawCoins();
        
        // Cl√©
        drawKey();
        
        // Dangers
        drawHazards();
        
        // Ennemis
        drawEnemies();
        
        // Boss
        if (currentLevelData.boss) {
            drawBoss();
        }
        
        // Projectiles
        drawProjectiles();
        
        // But
        drawGoal();
        
        // Joueur
        player.draw(ctx);
        
        // Particules
        ParticleSystem.draw(ctx);
        
        ctx.restore();
        ctx.restore();
    }

    function drawNotebookGrid() {
        ctx.strokeStyle = "rgba(100, 180, 255, 0.3)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        for (let y = 0; y < canvas.height; y += 30) {
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
        }
        ctx.stroke();
        
        ctx.strokeStyle = "rgba(255, 100, 100, 0.4)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(40, 0);
        ctx.lineTo(40, canvas.height);
        ctx.stroke();
    }

    function drawClouds() {
        ctx.fillStyle = "rgba(255,255,255,0.8)";
        for (const c of currentLevelData.clouds) {
            ctx.beginPath();
            ctx.arc(c.x, c.y, c.w / 2, 0, Math.PI * 2);
            ctx.arc(c.x + c.w / 2, c.y - 10, c.w / 2, 0, Math.PI * 2);
            ctx.arc(c.x + c.w, c.y, c.w / 2, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    function drawPortals() {
        for (const p of currentLevelData.portals) {
            ctx.strokeStyle = p.color;
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.ellipse(p.x + p.w / 2, p.y + p.h / 2, p.w / 2, p.h / 2, 0, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.fillStyle = p.color;
            ctx.globalAlpha = 0.3 + Math.sin(state.frameTick * 0.1) * 0.1;
            ctx.fill();
            ctx.globalAlpha = 1;
        }
    }

    function drawFireBars() {
        for (const fb of currentLevelData.fireBars) {
            const endX = fb.cx + Math.cos(fb.angle) * fb.length;
            const endY = fb.cy + Math.sin(fb.angle) * fb.length;
            
            // Barre
            ctx.strokeStyle = "#ff6600";
            ctx.lineWidth = 8;
            ctx.beginPath();
            ctx.moveTo(fb.cx, fb.cy);
            ctx.lineTo(endX, endY);
            ctx.stroke();
            
            // Boules de feu
            for (let i = 0; i <= 4; i++) {
                const px = fb.cx + (endX - fb.cx) * (i / 4);
                const py = fb.cy + (endY - fb.cy) * (i / 4);
                
                ctx.fillStyle = i % 2 === 0 ? "#ff3300" : "#ffcc00";
                ctx.beginPath();
                ctx.arc(px, py, 10 - i, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Centre
            ctx.fillStyle = "#555";
            ctx.beginPath();
            ctx.arc(fb.cx, fb.cy, 12, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    function drawLadders() {
        for (const l of currentLevelData.ladders) {
            ctx.strokeStyle = state.level === 7 ? "#4444ff" : "#795548";
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(l.x, l.y);
            ctx.lineTo(l.x, l.y + l.h);
            ctx.moveTo(l.x + l.w, l.y);
            ctx.lineTo(l.x + l.w, l.y + l.h);
            
            for (let i = 0; i < l.h; i += 30) {
                ctx.moveTo(l.x, l.y + i);
                ctx.lineTo(l.x + l.w, l.y + i);
            }
            ctx.stroke();
        }
    }

    function drawPlatforms() {
        for (const p of currentLevelData.platforms) {
            if (p.type === 'slide') continue;
            
            switch (p.type) {
                case 'slide_visual':
                    ctx.fillStyle = "rgba(241, 196, 15, 0.8)";
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(p.x + p.w, p.y + p.h);
                    ctx.lineTo(p.x, p.y + p.h);
                    ctx.fill();
                    ctx.strokeStyle = "#e67e22";
                    ctx.lineWidth = 5;
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(p.x + p.w, p.y + p.h);
                    ctx.stroke();
                    break;
                    
                case 'moving':
                    ctx.fillStyle = "#3498db";
                    ctx.fillRect(p.x, p.y, p.w, p.h);
                    ctx.strokeStyle = "#2980b9";
                    ctx.lineWidth = 3;
                    ctx.strokeRect(p.x, p.y, p.w, p.h);
                    ctx.fillStyle = "white";
                    ctx.fillRect(p.x + 5, p.y + 5, 5, 5);
                    ctx.fillRect(p.x + p.w - 10, p.y + 5, 5, 5);
                    break;
                    
                case 'pipe':
                    ctx.fillStyle = "#27ae60";
                    ctx.fillRect(p.x, p.y, p.w, p.h);
                    ctx.strokeStyle = "#1e8449";
                    ctx.lineWidth = 4;
                    ctx.strokeRect(p.x, p.y, p.w, p.h);
                    ctx.fillRect(p.x - 5, p.y, p.w + 10, 30);
                    ctx.strokeRect(p.x - 5, p.y, p.w + 10, 30);
                    break;
                    
                case 'brick_block':
                    ctx.fillStyle = "#d35400";
                    ctx.fillRect(p.x, p.y, p.w, p.h);
                    ctx.strokeStyle = "#333";
                    ctx.lineWidth = 2;
                    ctx.strokeRect(p.x, p.y, p.w, p.h);
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y + p.h / 2);
                    ctx.lineTo(p.x + p.w, p.y + p.h / 2);
                    ctx.moveTo(p.x + p.w / 2, p.y);
                    ctx.lineTo(p.x + p.w / 2, p.y + p.h / 2);
                    ctx.stroke();
                    break;
                    
                case 'brick_floor':
                    ctx.fillStyle = "#c45d16";
                    ctx.fillRect(p.x, p.y, p.w, p.h);
                    ctx.fillStyle = "#27ae60";
                    ctx.fillRect(p.x, p.y, p.w, 10);
                    break;
                    
                case 'gold_block':
                    ctx.fillStyle = "gold";
                    ctx.fillRect(p.x, p.y, p.w, p.h);
                    ctx.strokeStyle = "#333";
                    ctx.strokeRect(p.x, p.y, p.w, p.h);
                    ctx.fillStyle = "#333";
                    ctx.font = "bold 20px sans-serif";
                    ctx.fillText("?", p.x + 12, p.y + 28);
                    break;
                    
                case 'castle':
                    ctx.fillStyle = "#eee";
                    ctx.fillRect(p.x, p.y, p.w, p.h);
                    ctx.fillStyle = "#333";
                    ctx.beginPath();
                    ctx.arc(p.x + p.w / 2, p.y + p.h, 20, Math.PI, 0);
                    ctx.fill();
                    ctx.fillRect(p.x, p.y - 20, 20, 20);
                    ctx.fillRect(p.x + p.w - 20, p.y - 20, 20, 20);
                    break;
                    
                case 'grass_block':
                    ctx.fillStyle = "#8B4513";
                    ctx.fillRect(p.x, p.y, p.w, p.h);
                    ctx.fillStyle = "#32CD32";
                    ctx.fillRect(p.x, p.y, p.w, 15);
                    ctx.strokeStyle = "#333";
                    ctx.lineWidth = 2;
                    ctx.strokeRect(p.x, p.y, p.w, p.h);
                    break;
                    
                case 'dirt_block':
                    ctx.fillStyle = "#5d4037";
                    ctx.fillRect(p.x, p.y, p.w, p.h);
                    ctx.strokeStyle = "#333";
                    ctx.lineWidth = 1;
                    ctx.strokeRect(p.x, p.y, p.w, p.h);
                    break;
                    
                case 'stone':
                    ctx.fillStyle = "#757575";
                    ctx.fillRect(p.x, p.y, p.w, p.h);
                    ctx.strokeStyle = "#333";
                    ctx.lineWidth = 2;
                    ctx.strokeRect(p.x, p.y, p.w, p.h);
                    break;
                    
                case 'wood':
                    ctx.fillStyle = "#5D4037";
                    ctx.fillRect(p.x, p.y, p.w, p.h);
                    ctx.strokeStyle = "#333";
                    ctx.lineWidth = 2;
                    ctx.strokeRect(p.x, p.y, p.w, p.h);
                    break;
                    
                case 'leaves':
                    ctx.fillStyle = "#228B22";
                    ctx.fillRect(p.x, p.y, p.w, p.h);
                    ctx.strokeStyle = "#333";
                    ctx.lineWidth = 2;
                    ctx.strokeRect(p.x, p.y, p.w, p.h);
                    break;
                    
                case 'netherrack':
                    ctx.fillStyle = "#800000";
                    ctx.fillRect(p.x, p.y, p.w, p.h);
                    ctx.strokeStyle = "#333";
                    ctx.lineWidth = 2;
                    ctx.strokeRect(p.x, p.y, p.w, p.h);
                    break;
                    
                case 'metal':
                    ctx.fillStyle = "#7f8c8d";
                    ctx.fillRect(p.x, p.y, p.w, p.h);
                    ctx.strokeStyle = "#95a5a6";
                    ctx.lineWidth = 2;
                    ctx.strokeRect(p.x, p.y, p.w, p.h);
                    ctx.fillStyle = "#333";
                    ctx.beginPath();
                    ctx.arc(p.x + 8, p.y + 8, 3, 0, Math.PI * 2);
                    ctx.arc(p.x + p.w - 8, p.y + 8, 3, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case 'castle_wall':
                    ctx.fillStyle = "#ff5722";
                    ctx.fillRect(p.x, p.y, p.w, p.h);
                    ctx.fillStyle = "#bf360c";
                    ctx.fillRect(p.x, p.y, 20, p.h);
                    ctx.fillRect(p.x + p.w - 20, p.y, 20, p.h);
                    ctx.strokeStyle = "#333";
                    ctx.strokeRect(p.x, p.y, p.w, p.h);
                    break;
                    
                case 'smb2_grass':
                    ctx.fillStyle = "#d82800";
                    ctx.fillRect(p.x, p.y, p.w, p.h);
                    ctx.fillStyle = "#00c000";
                    ctx.fillRect(p.x, p.y, p.w, 15);
                    ctx.strokeStyle = "#333";
                    ctx.strokeRect(p.x, p.y, p.w, p.h);
                    break;
                    
                case 'smb2_log':
                    ctx.fillStyle = "#d8a080";
                    ctx.fillRect(p.x, p.y, p.w, p.h);
                    ctx.strokeStyle = "#5a3000";
                    ctx.lineWidth = 2;
                    ctx.strokeRect(p.x, p.y, p.w, p.h);
                    break;
                    
                case 'jar':
                    ctx.fillStyle = "#d82800";
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(p.x + p.w, p.y);
                    ctx.lineTo(p.x + p.w - 5, p.y + p.h);
                    ctx.lineTo(p.x + 5, p.y + p.h);
                    ctx.fill();
                    ctx.strokeStyle = "#333";
                    ctx.stroke();
                    ctx.fillStyle = "white";
                    ctx.fillRect(p.x + 5, p.y + 10, p.w - 10, 10);
                    break;
                    
                case 'boss_floor':
                    ctx.fillStyle = "#2d1b4e";
                    ctx.fillRect(p.x, p.y, p.w, p.h);
                    ctx.fillStyle = "#9b59b6";
                    ctx.fillRect(p.x, p.y, p.w, 5);
                    // Motif
                    for (let i = 0; i < p.w; i += 40) {
                        ctx.fillStyle = "#8e44ad";
                        ctx.fillRect(p.x + i, p.y + 5, 20, 10);
                    }
                    break;
                    
                default:
                    ctx.fillStyle = state.level === 3 ? "#5d4037" : "#2c3e50";
                    ctx.fillRect(p.x, p.y, p.w, p.h);
                    ctx.strokeStyle = state.level === 3 ? "#8d6e63" : "#27ae60";
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    for (let i = 0; i < p.w; i += 10) {
                        ctx.lineTo(p.x + i + 5, p.y - 5);
                        ctx.lineTo(p.x + i + 10, p.y);
                    }
                    ctx.stroke();
            }
        }
    }

    function drawCoins() {
        for (const c of currentLevelData.coins) {
            const wobble = Math.sin(state.frameTick * 0.1 + c.x) * 2;
            
            ctx.fillStyle = "gold";
            ctx.beginPath();
            ctx.ellipse(c.x + c.w / 2, c.y + c.h / 2 + wobble, c.w / 2, c.h / 2, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = "#b8860b";
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Brillance
            ctx.fillStyle = "rgba(255,255,255,0.5)";
            ctx.beginPath();
            ctx.arc(c.x + c.w / 3, c.y + c.h / 3 + wobble, 3, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    function drawKey() {
        if (state.hasKey || !currentLevelData.keyItem) return;
        
        const k = currentLevelData.keyItem;
        const wobble = Math.sin(state.frameTick * 0.1) * 3;
        
        switch (k.type) {
            case 'diamond':
                ctx.fillStyle = "#00BFFF";
                ctx.beginPath();
                ctx.moveTo(k.x + k.w / 2, k.y + wobble);
                ctx.lineTo(k.x + k.w, k.y + k.h / 2 + wobble);
                ctx.lineTo(k.x + k.w / 2, k.y + k.h + wobble);
                ctx.lineTo(k.x, k.y + k.h / 2 + wobble);
                ctx.fill();
                ctx.strokeStyle = "#fff";
                ctx.lineWidth = 2;
                ctx.stroke();
                break;
                
            case 'turnip':
                ctx.fillStyle = "white";
                ctx.beginPath();
                ctx.arc(k.x + 15, k.y + 20 + wobble, 12, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = "green";
                ctx.beginPath();
                ctx.moveTo(k.x + 15, k.y + 8 + wobble);
                ctx.lineTo(k.x + 5, k.y - 5 + wobble);
                ctx.lineTo(k.x + 25, k.y - 5 + wobble);
                ctx.fill();
                break;
                
            default:
                // Cl√© dor√©e standard
                ctx.fillStyle = "gold";
                ctx.beginPath();
                ctx.arc(k.x + 15, k.y + 10 + wobble, 10, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillRect(k.x + 12, k.y + 10 + wobble, 6, 25);
                ctx.fillRect(k.x + 12, k.y + 25 + wobble, 12, 5);
                ctx.fillRect(k.x + 12, k.y + 32 + wobble, 10, 5);
                
                // Brillance
                if (state.frameTick % 40 < 20) {
                    ctx.fillStyle = "white";
                    ctx.beginPath();
                    ctx.arc(k.x + 10, k.y + 5 + wobble, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
        }
    }

    function drawHazards() {
        for (const h of currentLevelData.hazards) {
            switch (h.type) {
                case 'spike':
                    ctx.fillStyle = "#c0392b";
                    ctx.beginPath();
                    ctx.moveTo(h.x, h.y + h.h);
                    ctx.lineTo(h.x + h.w / 2, h.y);
                    ctx.lineTo(h.x + h.w, h.y + h.h);
                    ctx.fill();
                    ctx.strokeStyle = "#922b21";
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    break;
                    
                case 'lava_floor':
                    ctx.fillStyle = "#e74c3c";
                    ctx.fillRect(h.x, h.y, h.w, h.h);
                    // Bulles
                    if (Math.random() < 0.1) {
                        ctx.fillStyle = "#f1c40f";
                        ctx.beginPath();
                        ctx.arc(h.x + Math.random() * 800, h.y + Math.random() * 20, 3 + Math.random() * 5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    break;
                    
                case 'knight':
                    ctx.fillStyle = "#c0c0c0";
                    ctx.fillRect(h.x, h.y, h.w, 30);
                    ctx.fillRect(h.x + 10, h.y + 30, 20, 50);
                    ctx.fillStyle = "#333";
                    ctx.fillRect(h.x + 10, h.y + 5, 20, 5);
                    // Lance
                    ctx.strokeStyle = "#8B4513";
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(h.x + h.w / 2, h.y);
                    ctx.lineTo(h.x + h.w / 2, h.y - 40);
                    ctx.stroke();
                    ctx.fillStyle = "#7f8c8d";
                    ctx.beginPath();
                    ctx.moveTo(h.x + h.w / 2, h.y - 40);
                    ctx.lineTo(h.x + h.w / 2 - 8, h.y - 25);
                    ctx.lineTo(h.x + h.w / 2 + 8, h.y - 25);
                    ctx.fill();
                    break;
            }
        }
    }

    function drawEnemies() {
        for (const e of currentLevelData.enemies) {
            switch (e.type) {
                case 'zombie':
                    // Corps
                    ctx.fillStyle = "#2ecc71";
                    ctx.fillRect(e.x, e.y, e.w, e.h);
                    // T√™te
                    ctx.fillRect(e.x - 5, e.y - 20, e.w + 10, 30);
                    // Yeux
                    ctx.fillStyle = "white";
                    ctx.beginPath();
                    ctx.arc(e.x + 12, e.y - 5, 8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(e.x + 32, e.y - 5, 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = "#333";
                    ctx.beginPath();
                    ctx.arc(e.x + 12, e.y - 5, 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(e.x + 32, e.y - 5, 2, 0, Math.PI * 2);
                    ctx.fill();
                    // Texte
                    ctx.fillStyle = "#333";
                    ctx.font = "bold 16px 'Patrick Hand'";
                    ctx.fillText("REEE!", e.x, e.y - 30);
                    // Pieds anim√©s
                    ctx.fillStyle = "#27ae60";
                    if (state.frameTick % 20 < 10) {
                        ctx.fillRect(e.x + 5, e.y + e.h, 10, 10);
                    } else {
                        ctx.fillRect(e.x + e.w - 15, e.y + e.h, 10, 10);
                    }
                    break;
                    
                case 'chest_monster':
                    // Coffre
                    ctx.fillStyle = "#8d6e63";
                    ctx.fillRect(e.x, e.y, e.w, e.h);
                    ctx.strokeStyle = "#333";
                    ctx.lineWidth = 2;
                    ctx.strokeRect(e.x, e.y, e.w, e.h);
                    // Dents
                    ctx.fillStyle = "white";
                    ctx.beginPath();
                    ctx.moveTo(e.x, e.y + 20);
                    for (let i = 0; i < e.w; i += 10) {
                        ctx.lineTo(e.x + i + 5, e.y + 30);
                        ctx.lineTo(e.x + i + 10, e.y + 20);
                    }
                    ctx.fill();
                    // Yeux
                    ctx.fillStyle = "#e74c3c";
                    ctx.beginPath();
                    ctx.arc(e.x + 15, e.y + 10, 5, 0, Math.PI * 2);
                    ctx.arc(e.x + e.w - 15, e.y + 10, 5, 0, Math.PI * 2);
                    ctx.fill();
                    // Trident
                    ctx.strokeStyle = "#e74c3c";
                    ctx.lineWidth = 3;
                    const tx = e.x + e.w + 10;
                    const ty = e.y + e.h;
                    ctx.beginPath();
                    ctx.moveTo(tx, ty);
                    ctx.lineTo(tx, ty - 50);
                    ctx.moveTo(tx - 10, ty - 50);
                    ctx.lineTo(tx + 10, ty - 50);
                    ctx.moveTo(tx - 10, ty - 50);
                    ctx.lineTo(tx - 10, ty - 65);
                    ctx.moveTo(tx, ty - 50);
                    ctx.lineTo(tx, ty - 70);
                    ctx.moveTo(tx + 10, ty - 50);
                    ctx.lineTo(tx + 10, ty - 65);
                    ctx.stroke();
                    break;
                    
                case 'shy_guy':
                    // Corps rouge
                    ctx.fillStyle = "#e74c3c";
                    ctx.fillRect(e.x, e.y, e.w, e.h);
                    // Masque blanc
                    ctx.fillStyle = "white";
                    ctx.beginPath();
                    ctx.arc(e.x + e.w / 2, e.y + 12, 12, 0, Math.PI * 2);
                    ctx.fill();
                    // Yeux et bouche
                    ctx.fillStyle = "#333";
                    ctx.beginPath();
                    ctx.arc(e.x + e.w / 2 - 5, e.y + 10, 2, 0, Math.PI * 2);
                    ctx.arc(e.x + e.w / 2 + 5, e.y + 10, 2, 0, Math.PI * 2);
                    ctx.arc(e.x + e.w / 2, e.y + 18, 3, 0, Math.PI * 2);
                    ctx.fill();
                    // Pieds bleus
                    ctx.fillStyle = "#3498db";
                    if (state.frameTick % 20 < 10) {
                        ctx.fillRect(e.x, e.y + e.h - 5, 10, 5);
                    } else {
                        ctx.fillRect(e.x + e.w - 10, e.y + e.h - 5, 10, 5);
                    }
                    break;
            }
        }
    }

    function drawBoss() {
        const boss = currentLevelData.boss;
        if (!boss || boss.hp <= 0) return;
        
        const flash = boss.invincible > 0 && boss.invincible % 10 < 5;
        
        ctx.save();
        
        // Corps principal
        ctx.fillStyle = flash ? "#fff" : "#9b59b6";
        ctx.fillRect(boss.x, boss.y, boss.w, boss.h);
        
        // Contour
        ctx.strokeStyle = "#6c3483";
        ctx.lineWidth = 5;
        ctx.strokeRect(boss.x, boss.y, boss.w, boss.h);
        
        // Couronne
        ctx.fillStyle = "gold";
        ctx.beginPath();
        ctx.moveTo(boss.x + 20, boss.y);
        ctx.lineTo(boss.x + 40, boss.y - 30);
        ctx.lineTo(boss.x + 60, boss.y);
        ctx.lineTo(boss.x + 80, boss.y - 40);
        ctx.lineTo(boss.x + 100, boss.y);
        ctx.lineTo(boss.x + 120, boss.y - 30);
        ctx.lineTo(boss.x + 130, boss.y);
        ctx.fill();
        
        // Yeux
        ctx.fillStyle = boss.phase === 2 ? "#e74c3c" : "white";
        ctx.beginPath();
        ctx.arc(boss.x + 45, boss.y + 60, 20, 0, Math.PI * 2);
        ctx.arc(boss.x + 105, boss.y + 60, 20, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = "#333";
        ctx.beginPath();
        ctx.arc(boss.x + 45, boss.y + 60, 8, 0, Math.PI * 2);
        ctx.arc(boss.x + 105, boss.y + 60, 8, 0, Math.PI * 2);
        ctx.fill();
        
        // Bouche m√©chante
        ctx.strokeStyle = "#333";
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(boss.x + 40, boss.y + 120);
        ctx.lineTo(boss.x + 55, boss.y + 100);
        ctx.lineTo(boss.x + 75, boss.y + 120);
        ctx.lineTo(boss.x + 95, boss.y + 100);
        ctx.lineTo(boss.x + 110, boss.y + 120);
        ctx.stroke();
        
        // Barre de vie
        const hpBarWidth = 100;
        const hpBarHeight = 12;
        const hpX = boss.x + (boss.w - hpBarWidth) / 2;
        const hpY = boss.y - 50;
        
        ctx.fillStyle = "#333";
        ctx.fillRect(hpX - 2, hpY - 2, hpBarWidth + 4, hpBarHeight + 4);
        
        ctx.fillStyle = "#c0392b";
        ctx.fillRect(hpX, hpY, hpBarWidth, hpBarHeight);
        
        ctx.fillStyle = "#27ae60";
        ctx.fillRect(hpX, hpY, (boss.hp / boss.maxHp) * hpBarWidth, hpBarHeight);
        
        ctx.restore();
    }

    function drawProjectiles() {
        for (const p of currentLevelData.projectiles) {
            switch (p.type) {
                case 'arrow':
                    ctx.fillStyle = "white";
                    ctx.fillRect(p.x, p.y, p.w, p.h);
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(p.x - 10, p.y + p.h / 2);
                    ctx.lineTo(p.x, p.y + p.h);
                    ctx.fill();
                    break;
                    
                case 'fireball':
                    ctx.fillStyle = "#ff6600";
                    ctx.beginPath();
                    ctx.arc(p.x + p.w / 2, p.y + p.h / 2, 15, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = "#ffcc00";
                    ctx.beginPath();
                    ctx.arc(p.x + p.w / 2, p.y + p.h / 2, 8, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case 'boss_fire':
                    ctx.fillStyle = "#9b59b6";
                    ctx.beginPath();
                    ctx.arc(p.x + p.w / 2, p.y + p.h / 2, p.w / 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = "#e74c3c";
                    ctx.beginPath();
                    ctx.arc(p.x + p.w / 2, p.y + p.h / 2, p.w / 4, 0, Math.PI * 2);
                    ctx.fill();
                    break;
            }
        }
    }

    function drawGoal() {
        if (!currentLevelData.goal) return;
        
        const g = currentLevelData.goal;
        
        // Niveau 8 : porte invisible sans cl√©
        if (state.level === 8 && !state.hasKey) {
            // Dessiner porte ferm√©e
            ctx.fillStyle = "#d82800";
            ctx.fillRect(g.x, g.y, g.w, g.h);
            ctx.fillStyle = "#333";
            ctx.fillRect(g.x + 10, g.y + 60, 60, 2);
            // Yeux ferm√©s
            ctx.fillStyle = "white";
            ctx.beginPath();
            ctx.arc(g.x + 20, g.y + 20, 8, 0, Math.PI * 2);
            ctx.arc(g.x + 60, g.y + 20, 8, 0, Math.PI * 2);
            ctx.fill();
            return;
        }
        
        switch (g.type) {
            case 'axe':
                ctx.fillStyle = "gold";
                ctx.fillRect(g.x, g.y, g.w, g.h);
                ctx.strokeStyle = "#333";
                ctx.strokeRect(g.x, g.y, g.w, g.h);
                ctx.fillStyle = "#333";
                ctx.font = "bold 20px sans-serif";
                ctx.fillText("FIN", g.x + 5, g.y + 35);
                break;
                
            case 'flag':
                ctx.fillStyle = "#27ae60";
                ctx.fillRect(g.x, g.y, 8, g.h);
                ctx.fillStyle = "gold";
                ctx.beginPath();
                ctx.arc(g.x + 4, g.y, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = "#e74c3c";
                ctx.beginPath();
                ctx.moveTo(g.x + 8, g.y + 10);
                ctx.lineTo(g.x + 40, g.y + 25);
                ctx.lineTo(g.x + 8, g.y + 40);
                ctx.fill();
                break;
                
            case 'nether_portal':
                ctx.fillStyle = "#6a0dad";
                ctx.fillRect(g.x, g.y, g.w, g.h);
                ctx.strokeStyle = "#333";
                ctx.lineWidth = 4;
                ctx.strokeRect(g.x, g.y, g.w, g.h);
                // Animation
                ctx.fillStyle = `rgba(138, 43, 226, ${0.5 + Math.sin(state.frameTick * 0.1) * 0.3})`;
                ctx.fillRect(g.x + 5, g.y + 5, g.w - 10, g.h - 10);
                break;
                
            case 'bell':
                ctx.fillStyle = "gold";
                ctx.beginPath();
                ctx.arc(g.x + g.w / 2, g.y + g.h / 2, 30, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = "#8B4513";
                ctx.fillRect(g.x + g.w / 2 - 5, g.y, 10, 20);
                ctx.strokeStyle = "#b8860b";
                ctx.lineWidth = 3;
                ctx.stroke();
                break;
                
            case 'hawkmouth':
                ctx.fillStyle = "#d82800";
                ctx.fillRect(g.x, g.y, g.w, g.h);
                // Bouche ouverte
                ctx.fillStyle = "#333";
                ctx.fillRect(g.x + 10, g.y + 40, 60, 60);
                // Yeux
                ctx.fillStyle = "white";
                ctx.beginPath();
                ctx.arc(g.x + 20, g.y + 20, 8, 0, Math.PI * 2);
                ctx.arc(g.x + 60, g.y + 20, 8, 0, Math.PI * 2);
                ctx.fill();
                break;
                
            default:
                // Porte standard
                ctx.fillStyle = "#f1c40f";
                ctx.fillRect(g.x, g.y, g.w, g.h);
                ctx.strokeStyle = "#333";
                ctx.lineWidth = 3;
                ctx.strokeRect(g.x, g.y, g.w, g.h);
                
                // Texte
                ctx.fillStyle = "#333";
                ctx.font = "bold 18px 'Patrick Hand'";
                const nextLvl = state.level < 9 ? `NIV ${state.level + 1}` : "FIN";
                ctx.fillText(nextLvl, g.x + 10, g.y - 10);
                
                // Poign√©e
                ctx.beginPath();
                ctx.arc(g.x + g.w - 15, g.y + g.h / 2, 5, 0, Math.PI * 2);
                ctx.fill();
                
                // Cadenas si pas de cl√©
                if (!state.hasKey && state.level !== 3) {
                    ctx.fillStyle = "#c0392b";
                    ctx.fillRect(g.x + 20, g.y + 30, 30, 30);
                    ctx.fillStyle = "white";
                    ctx.font = "24px sans-serif";
                    ctx.fillText("üîí", g.x + 22, g.y + 55);
                    
                    if (Math.abs(player.x - g.x) < 100) {
                        ctx.fillStyle = "#c0392b";
                        ctx.font = "bold 20px 'Patrick Hand'";
                        ctx.fillText("IL FAUT LA CL√â !", g.x - 40, g.y - 30);
                    }
                }
        }
    }

    // ===== HUD =====
    function updateHud() {
        let hearts = "";
        for (let i = 0; i < state.lives; i++) hearts += "‚ù§Ô∏è";
        for (let i = state.lives; i < 3; i++) hearts += "üñ§";
        document.getElementById('hearts').textContent = hearts;
    }

    function updateCoinsDisplay() {
        document.getElementById('coins-display').textContent = `ü™ô ${state.coins}`;
    }

    function updateTimerDisplay() {
        const seconds = Math.floor(state.levelTime / 1000);
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        document.getElementById('timer-display').textContent = 
            `‚è±Ô∏è ${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }

    // ===== FIN DE NIVEAU =====
    function levelWin() {
        state.current = GameState.TRANSITIONING;
        AudioSystem.play('victory');
        saveGame();
        
        const isFinalLevel = state.level >= CONFIG.TOTAL_LEVELS;
        
        document.getElementById('msg-title').textContent = 
            isFinalLevel ? "üèÜ VICTOIRE TOTALE !" : `NIVEAU ${state.level} R√âUSSI !`;
        document.getElementById('msg-title').style.color = isFinalLevel ? "gold" : "#27ae60";
        
        document.getElementById('msg-text').textContent = 
            isFinalLevel ? "Tu as vaincu le boss et termin√© le jeu !" : "Pr√™t pour la suite ?";
        
        document.getElementById('msg-coins').textContent = 
            `Pi√®ces : ${state.coins} | Total : ${state.totalCoins}`;
        
        document.getElementById('msg-btn').textContent = 
            isFinalLevel ? "üéâ Rejouer" : "Continuer ‚ñ∂";
        
        document.getElementById('msg-hint').textContent = "(ESPACE pour continuer)";
        document.getElementById('message-box').style.display = "block";
    }

    function gameOver(reason) {
        state.current = GameState.GAME_OVER;
        AudioSystem.play('death');
        
        document.getElementById('msg-title').textContent = "üíÄ GAME OVER";
        document.getElementById('msg-title').style.color = "#e74c3c";
        document.getElementById('msg-text').textContent = reason || "Plus de vies...";
        document.getElementById('msg-coins').textContent = `Pi√®ces collect√©es : ${state.totalCoins}`;
        document.getElementById('msg-btn').textContent = "Recommencer";
        document.getElementById('msg-hint').textContent = "(ESPACE pour rejouer)";
        document.getElementById('message-box').style.display = "block";
    }

    function nextLevelAction() {
        document.getElementById('message-box').style.display = 'none';
        
        if (state.level >= CONFIG.TOTAL_LEVELS || state.current === GameState.GAME_OVER) {
            // Retour au menu
            state.level = 1;
            state.current = GameState.MENU;
            document.getElementById('start-screen').style.display = 'flex';
            if (state.animationId) cancelAnimationFrame(state.animationId);
            return;
        }
        
        // Transition vers niveau suivant
        showTransition(state.level + 1, () => {
            state.level++;
            initLevel(state.level);
            updateProgressBar();
            state.current = GameState.PLAYING;
            state.lastTime = 0;
            state.accumulator = 0;
        });
    }

    function showTransition(levelNum, callback) {
        const screen = document.getElementById('transition-screen');
        const text = document.getElementById('transition-text');
        const levelDef = LEVELS[levelNum];
        
        text.textContent = levelDef.isBoss ? "‚öîÔ∏è BOSS FINAL ‚öîÔ∏è" : `NIVEAU ${levelNum}`;
        text.style.textShadow = levelDef.isBoss ? "0 0 20px #9b59b6" : "none";
        
        screen.style.display = 'flex';
        screen.style.opacity = '0';
        
        setTimeout(() => { screen.style.opacity = '1'; }, 50);
        
        setTimeout(() => {
            screen.style.opacity = '0';
            setTimeout(() => {
                screen.style.display = 'none';
                callback();
            }, 500);
        }, 1500);
    }

    // ===== PAUSE =====
    function togglePause() {
        if (state.current === GameState.PLAYING) {
            state.current = GameState.PAUSED;
            document.getElementById('pause-screen').style.display = 'flex';
            document.getElementById('pause-level').textContent = state.level;
        } else if (state.current === GameState.PAUSED) {
            resumeGame();
        }
    }

    function resumeGame() {
        state.current = GameState.PLAYING;
        document.getElementById('pause-screen').style.display = 'none';
        state.lastTime = 0;
    }

    function restartLevel() {
        document.getElementById('pause-screen').style.display = 'none';
        state.lives = 3;
        state.coins = 0;
        updateHud();
        initLevel(state.level);
        state.current = GameState.PLAYING;
        state.lastTime = 0;
    }

    function quitToMenu() {
        document.getElementById('pause-screen').style.display = 'none';
        state.current = GameState.MENU;
        document.getElementById('start-screen').style.display = 'flex';
        if (state.animationId) cancelAnimationFrame(state.animationId);
    }

    // ===== OPTIONS =====
    function toggleSound() {
        state.soundEnabled = !state.soundEnabled;
        AudioSystem.enabled = state.soundEnabled;
        document.getElementById('sound-toggle').classList.toggle('active', state.soundEnabled);
    }

    function toggleTimer() {
        state.timerEnabled = !state.timerEnabled;
        document.getElementById('timer-toggle').classList.toggle('active', state.timerEnabled);
        document.getElementById('timer-display').style.display = state.timerEnabled ? 'block' : 'none';
    }

    // ===== D√âMARRAGE =====
    window.startGame = startGame;
    window.continueSavedGame = continueSavedGame;
    window.closeTutorial = closeTutorial;
    window.nextLevelAction = nextLevelAction;
    window.togglePause = togglePause;
    window.resumeGame = resumeGame;
    window.restartLevel = restartLevel;
    window.quitToMenu = quitToMenu;
    window.toggleSound = toggleSound;
    window.toggleTimer = toggleTimer;

    init();
    </script>
</body>
</html>